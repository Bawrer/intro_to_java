# intro_to_java
## week 1 day 1
Java is a high-level, object-oriented programming language that is designed to be platform-independent, meaning that Java programs can run on any device that has a Java Virtual Machine (JVM) installed.

## Advantages of Java:
1. Object-Oriented Programming (OOP): Java is a pure object-oriented programming language, which promotes code organization, reusability, and maintainability.

2. Strong Community Support: Java has a large and active community, which means there are extensive resources, libraries, and frameworks available. Developers can easily find support and solutions to their problems.

3. Scalability: Java is known for its scalability, making it suitable for building large-scale enterprise applications.

## disadvantages:

1. Performance: While the performance of Java has improved over the years, some low-level languages, like C or C++, may still offer better performance for certain types of applications.

2. Startup Time: Java applications may have a longer startup time compared to languages that are compiled to native code.

3. Learning Curve: Java's extensive ecosystem and libraries can make it challenging for beginners to learn the language quickly.

# java components

## java code(.java file)
 – this is the java code you have written, and its saved in the .java file(s)

## javac compiler:
 compile the source code files(.java) into a bytecode so that the jmv will be execute it.Bytecode is saved in a class file by compiler.

 ## Bytecode

 the resulting code after the source code has been executed by the compiler.

 ## Java Virtual Machine (JVM)

the primary function used to execute the bytecode produced by the compiler.

every os has its jvm, the output after execution of bytecode is the same accross all OS, that is why java is platform independent.

## steps to follow when executing a code
1. write a java program in an IDE with exwntion .java

2. the javac compiler is the primary compiler included in the JDK. It takes program as an input and convert it into java bytecode as an output

3. Java Virtual machine- it executes the bytecode generated by the compiler and this phase is called RUN PHASE.

## jdk 
complete Java development kit that includes JRE, compiler, and some more tools like javaDoc, java Debugger and more.
for you as a programmer you need to have JDK in order to be able to create java programs.

## JRE
 is the runtime environment required for running Java applications. It includes the JVM and other libraries that are needed for running Java programs but not for compiling them.

 # java Main features

 ## Platform Independence (Write Once, Run Anywhere):
 Java programs are compiled into bytecode, which is an intermediate form that can be executed on any device with a Java Virtual Machine (JVM).

## Object-Oriented: 
Java is designed around the principles of object-oriented programming (OOP). It supports concepts such as classes, objects, inheritance, polymorphism, and encapsulation, making it easy to organize and structure code.

## simple
 Java has a straightforward syntax, and its popularity has led to a large and active developer community. There are plenty of resources, tutorials, and forums available for learning and getting support.

## Robust language

when Java is described as a "robust" programming language, it refers to its ability to provide strong safeguards against errors and its capability to handle unexpected conditions gracefully.

## Security:
 Java has built-in security features, including a robust security model and a bytecode verifier, which helps ensure that code running on the JVM is safe and doesn't violate security constraints

## Multithreading:
 Java supports multithreading, allowing developers to write programs that can perform multiple tasks concurrently

 ## setting up the environment
etting up a Java development environment involves installing the Java Development Kit (JDK) and an Integrated Development Environment (IDE). Here are the steps to set up a basic Java environment:

1. Install the Java Development Kit (JDK):
## For Windows:
## Download JDK:
Visit the Oracle JDK download page or use an alternative like OpenJDK.

## Install JDK:
Follow the installation instructions provided on the download page.

## Set the PATH variable:
Add the JDK bin directory to your system's PATH variable. This allows you to run Java commands from any command prompt.

## java first program
public class firstProgram {
   public static void main(String[]args){
      System.out.println("hello world");
   }

} 


## First program Explained
public class HelloWorld {-: Every java application must have at least one class definition that consists of class keyword followed by classname. In this case classname is HelloWorld

public static void main (String[]args) {  this line is the main method. lets break the second line of code in our program to 
public : This makes the main method public that means that we can call the method from outside the class.

static : We do not need to create object for static methods to run. They can run itself.

void : It does not return anything.

main: It is the method name. This is the entry point method from which the JVM can run your program.

String [] args: Used for command line arguments that are passed as strings.

System.out println("Hello World"); -: This method prints the contents inside the double quotes into the console and inserts a newline after


# Structure of a java program
 
1. **Package Declaration:**
   Java programs often start with a package declaration. A package is a way to organize related classes. It is not mandatory, but it's good practice to include it. For example:

   ```java
   package com.example.myprogram;
   ```

2. **Import Statements:**
   After the package declaration, you may have import statements. These statements allow you to use classes from other packages without having to use their fully qualified names. For example:

   ```java
   import java.util.Scanner;
   ```

3. **Class Declaration:**
   A Java program must have at least one class, and the main class should have a `main` method where the program execution begins. The class name should match the filename (excluding the .java extension). For example:

   ```java
   public class Main {
       public static void main(String[] args) {
           // Program logic goes here
       }
   }
   ```

4. **Comments:**
   Comments are used to explain the code and are not executed by the compiler. They can be single-line (`//`) or multi-line (`/* */`). For example:

   ```java
   // This is a single-line comment

   /*
   This is a multi-line comment.
   It can span multiple lines.
   */
   ```

5. **Variables:**
   Declare variables to store data. Java is statically typed, so you need to specify the data type of each variable. For example:

   ```java
   int age = 25;
   String name = "John";
   ```

6. **Methods:**
   Methods are blocks of code that perform a specific task. The `main` method is the entry point of a Java program, and other methods are defined as needed. For example:

   ```java
   public static void main(String[] args) {
       // Program logic goes here
   }

   public static int addNumbers(int a, int b) {
       return a + b;
   }
   ```

7. **Control Flow Statements:**
   Use control flow statements like `if`, `else`, `while`, `for`, etc., to control the flow of execution in your program. For example:

   ```java
   if (condition) {
       // Code to execute if the condition is true
   } else {
       // Code to execute if the condition is false
   }

   for (int i = 0; i < 5; i++) {
       // Code to repeat multiple times
   }
   ```

8. **Object-Oriented Features:**
   Java is an object-oriented programming language, and programs often involve creating classes and objects. You might use concepts like inheritance, encapsulation, and polymorphism.

9. **Exception Handling:**
   Java provides exception handling with `try`, `catch`, `finally`, and `throw` statements to deal with runtime errors. For example:

   ```java
   try {
       // Code that might throw an exception
   } catch (Exception e) {
       // Code to handle the exception
   } finally {
       // Code that will be executed regardless of whether an exception occurs or not
   }
   ```

10. **Documentation:**
    It's a good practice to include documentation for your classes and methods using JavaDoc comments. For example:

    ```java
    /**
     * This is a JavaDoc comment for the MyClass class.
     */
    public class MyClass {
        /**
         * This is a JavaDoc comment for the myMethod method.
         * @param param1 Description of parameter 1
         * @param param2 Description of parameter 2
         * @return Description of the return value
         */
        public int myMethod(int param1, int param2) {
            // Method logic goes here
        }
    }
    ```

Remember, this is a basic structure, and the actual structure can vary based on the complexity and purpose of the program. It's also common to organize code into multiple classes and packages for larger projects.

# day2
 
What is a variable? 

A variable is a name given to a memory location. It is the basic unit of storage in a program. 

The value stored in a variable can be changed during program execution. 

A variable is only a name given to a memory location; all the operations done on the variable effects that memory location. 

In Java, all the variables must be declared before use. 

How to declare variables? 

type: Type of data that can be stored in this variable. 

name: Name given to the variable. 

It can be assigned values in two ways: 

Variable Initialization 

Assigning value by taking input. 

 

Declaring and initialize variables: 

datatype: Type of data that can be stored in this variable. 

variable_name: Name given to the variable. 

value: It is the initial value stored in the variable. 

Declaring variables examples 

float simpleInterest; - Declaring float variable 

int myAge = 19; - Declaring and Initializing integer variable 

char firstLetter = 'h'; - Declaring and Initializing character variable 

 

 

There are three types of variables in Java: 

 

Local Variables: A variable defined within a block or method or constructor is called local variable. 

Instance Variables: Instance variables are non-static variables and are declared in a class outside any method, constructor or block. 

Static Variables: Static variables are also known as Class variables. 

 

Data types in Java: 

1) Primitive data types - A primitive data type specifies the size and type of variable values, and it has no additional methods. 

2)  Non-primitive data types – Arrays and Strings are non-primitive data types, these are the datatypes which have instances like objects. Hence, they are called reference variables. They are primarily classes, arrays, strings or interfaces. 

 

There are eight primitive data types in Java: 

Byte 

Short 

Int 

Long 

Float 

Double 

Boolean 

Char 

# day 3 OOP

what is OOP?
OOP stands for Object-Oriented Programming, and it is a programming paradigm based on the concept of "objects." Java is a widely used object-oriented programming language, and it embodies the principles of OOP.

Key Concepts in Java OOP:
Class:

A class is a blueprint or template for creating objects. It defines attributes (fields) and behaviors (methods) that the objects will have.
Object:

An object is an instance of a class. It is a concrete realization of the class blueprint and represents a specific entity in the program.
Method:

A method is a function defined within a class. It represents the behavior or actions that objects of the class can perform.
Instance Variable:

An instance variable is a variable defined in a class and represents the state or properties of an object.
Constructor:

A constructor is a special method used for initializing objects when they are created. It has the same name as the class and is called automatically when an object is instantiated.
Java's support for OOP allows for the creation of modular, reusable, and maintainable code. The use of classes and objects facilitates the modeling of real-world entities and their interactions, making it easier to manage and understand complex systems.

# activity 1
Object-oriented programming (OOP) has become more popular than declarative and procedural programming for several reasons, and its popularity can be attributed to the following advantages:

Modularity and Reusability:

OOP promotes the concept of encapsulation, allowing the bundling of data and methods into a single unit (class). This leads to modular code, where each class represents a self-contained module with well-defined interfaces. This modularity facilitates code organization and makes it easier to reuse and maintain code components.
Code Reusability:

Inheritance in OOP allows for the creation of new classes that inherit properties and behaviors from existing classes. This promotes code reuse and reduces redundancy. Developers can extend existing classes to create new ones without rewriting the entire code.
Abstraction:

OOP provides abstraction, allowing developers to focus on the essential properties and behaviors of objects while hiding unnecessary details. Abstract classes and interfaces enable the creation of high-level, generalized blueprints that can be extended to create more specific implementations.
Encapsulation:

Encapsulation encapsulates the implementation details within a class, exposing only necessary interfaces to the outside world. This reduces the complexity of the code, improves maintainability, and minimizes the risk of unintended interference with the internal workings of a class.

Flexibility and Extensibility:

OOP languages support polymorphism, allowing objects of different types to be treated as objects of a common type. This flexibility enables the development of generic and extensible code, making it easier to adapt to changing requirements.
Modeling Real-World Concepts:

OOP is well-suited for modeling and simulating real-world entities and their relationships. Concepts like objects, classes, and inheritance closely align with how we think about and categorize things in the real world. This makes OOP a natural choice for applications where the goal is to model and represent complex systems.
Collaborative Development:

OOP encourages the creation of well-defined interfaces and contracts between different parts of a program. This helps in collaborative development, where teams can work on different parts of a system independently as long as they adhere to the specified interfaces.
Graphical User Interface (GUI) Development:

OOP is often the preferred paradigm for developing graphical user interfaces. The concept of objects representing visual elements and their interactions aligns well with GUI design principles.

# Features of OOP – Core features

1.Encapsulation
2. polymorphism
3. inheritance
4. abstraction

### Encapsulation:
Encapsulation refers to the bundling of data (attributes) and methods (functions) that operate on the data into a single unit known as a class. A class serves as a blueprint for creating objects, and it encapsulates the internal details of how an object works.

### Polymorphism:
Polymorphism allows objects of different types to be treated as objects of a common type. There are two types of polymorphism in Java: compile-time polymorphism (method overloading) and runtime polymorphism (method overriding). Polymorphism makes it possible to write more generic and reusable code.

### Inheritance:

Inheritance allows a class (subclass or derived class) to inherit the properties and behaviors of another class (superclass or base class). This promotes code reuse and establishes a hierarchy of classes, where a subclass can extend or override the functionality of its superclass.

### Abstraction:
Abstraction involves simplifying complex systems by modeling classes based on the essential properties and behaviors relevant to the problem. It allows programmers to focus on what an object does rather than how it achieves its functionality. Abstract classes and interfaces are used to achieve abstraction in Java.

# activity 2
Here are the three Java classes based on the provided information:

1. **PurchaseItem Class:**
   ```java
   public class PurchaseItem {
       private String name;
       private double unitPrice;

       // Constructor to initialize instance variables
       public PurchaseItem(String name, double unitPrice) {
           this.name = name;
           this.unitPrice = unitPrice;
       }

       // Default constructor
       public PurchaseItem() {
           this.name = "no item";
           this.unitPrice = 0;
       }

       // Method to get the unit price
       public double getPrice() {
           return unitPrice;
       }
   }
   ```

2. **WeighedItem Class (Subclass of PurchaseItem):**
   ```java
   public class WeighedItem extends PurchaseItem {
       private double weight;

       // Constructor using superclass constructor
       public WeighedItem(String name, double unitPrice, double weight) {
           super(name, unitPrice);
           this.weight = weight;
       }

       // Override getPrice method
       @Override
       public double getPrice() {
           // Calculate the price based on unit price and weight
           return super.getPrice() * weight;
       }
   }
   ```

3. **CountedItem Class (Subclass of PurchaseItem):**
   ```java
   public class CountedItem extends PurchaseItem {
       private int quantity;

       // Constructor using superclass constructor
       public CountedItem(String name, double unitPrice, int quantity) {
           super(name, unitPrice);
           this.quantity = quantity;
       }

       // Override getPrice method
       @Override
       public double getPrice() {
           // Calculate the price based on unit price and quantity
           return super.getPrice() * quantity;
       }
   }
   ```

Example of using these classes:

```java
public class Main {
    public static void main(String[] args) {
        // Example of WeighedItem
        WeighedItem banana = new WeighedItem("Banana", 3.00, 1.37);
        System.out.println(banana.getName() + " @ " + banana.getPrice() + " R" + banana.getPrice());

        // Example of CountedItem
        CountedItem pens = new CountedItem("Pens", 4.5, 10);
        System.out.println(pens.getName() + " @ " + pens.getPrice() + " R" + pens.getPrice());
    }
}
```

In this example, the `WeighedItem` and `CountedItem` classes extend the `PurchaseItem` class. The `getPrice` method is overridden in each subclass to calculate the total price based on the specific properties of that item (weight or quantity). The `super.getPrice()` call is used to access the `getPrice` method of the superclass.

# Features of OOP – Other features

 coupling, cohesion, association, aggregation, and composition—additional concepts related to object-oriented design and programming.

1. **Coupling:**
   - **Definition:** Coupling refers to the degree of dependence between classes or modules. It measures how much one class knows about another. Low coupling is desirable as it leads to more maintainable and flexible systems.
   - **Types:**
     - **Low Coupling:** Classes have minimal knowledge of each other. Changes in one class have minimal impact on others.
     - **High Coupling:** Classes are closely connected, and changes in one class may require changes in others.

2. **Cohesion:**
   - **Definition:** Cohesion measures how closely the elements within a module (class or method) are related to each other. High cohesion is desirable as it leads to more maintainable and understandable code.
   - **Types:**
     - **High Cohesion:** Elements within a module are closely related and work together to achieve a common goal.
     - **Low Cohesion:** Elements within a module have weak relationships and may not contribute to a common goal.

3. **Association:**
   - **Definition:** Association represents a bi-directional relationship between two classes. It can be a one-to-one, one-to-many, or many-to-many relationship.
   - **Example:** In a university system, a `Student` class may be associated with a `Course` class through enrollment.

4. **Aggregation:**
   - **Definition:** Aggregation is a special form of association representing a "whole-part" relationship between classes. It implies that one class (the whole) contains another class (the part), but the part can exist independently.
   - **Example:** In a car example, a `Car` class may have an aggregation relationship with a `Wheel` class. A `Car` has wheels, and wheels can exist independently.

5. **Composition:**
   - **Definition:** Composition is a stronger form of aggregation, where the part cannot exist independently of the whole. If the whole is destroyed, all its parts are destroyed as well.
   - **Example:** In a computer example, a `Computer` class may have a composition relationship with a `CPU` class. If the `Computer` is destroyed, the `CPU` is also destroyed.

Understanding these concepts is crucial for designing systems with maintainability, flexibility, and clarity in mind. Properly managing coupling and cohesion helps create systems that are easier to modify and extend. Meanwhile, understanding association, aggregation, and composition allows for modeling real-world relationships more accurately in your code.

## activity 3
Certainly! Below are three Java classes, `Company`, `Store`, and `Product`, demonstrating the relationships using association and aggregation:

1. **Product Class:**
   ```java
   public class Product {
       private String name;
       private int quantity;
       private double price;

       // Constructor
       public Product(String name, int quantity, double price) {
           this.name = name;
           this.quantity = quantity;
           this.price = price;
       }

       // Getters and Setters (not shown for brevity)
   }
   ```

2. **Store Class (Aggregation with Product):**
   ```java
   import java.util.ArrayList;
   import java.util.List;

   public class Store {
       private String name;
       private String location;
       private List<Product> productList;

       // Constructor
       public Store(String name, String location) {
           this.name = name;
           this.location = location;
           this.productList = new ArrayList<>();
       }

       // Aggregation: Adding a Product to the ProductList
       public void addProduct(Product product) {
           productList.add(product);
       }

       // Getters and Setters (not shown for brevity)
   }
   ```

3. **Company Class (Association with Store):**
   ```java
   import java.util.ArrayList;
   import java.util.List;

   public class Company {
       private String name;
       private List<Store> storeList;

       // Constructor
       public Company(String name) {
           this.name = name;
           this.storeList = new ArrayList<>();
       }

       // Association: Adding a Store to the StoreList
       public void addStore(Store store) {
           storeList.add(store);
       }

       // Getters and Setters (not shown for brevity)
   }
   ```

In the above demo:

- The `Product` class represents a product with attributes such as name, quantity, and price.
- The `Store` class represents a store with attributes like name, location, and a list of products. The relationship with `Product` is aggregation, as a store contains products, and products can exist independently.
- The `Company` class represents a company with a name and a list of stores. The relationship with `Store` is association, as a company is associated with multiple stores.


# Day 4 

## Introduction to Decision control 

 

Decision control in Java refers to the programming constructs that allow you to control the flow of execution based on certain conditions or decisions.  

 

### There are mainly three decision-making structures in Java: 

  

1. if statement: 

   - The `if` statement evaluates a boolean expression and executes a block of code only if the condition is true. 

    

   Syntax: 

   ```java 

   if (condition) { 

       // Code to be executed if the condition is true 

   } 

   ``` 

  

2. **if-else statement:** 

   - The `if-else` statement allows the program to execute one block of code if the condition is true and another block if the condition is false. 

    

   Syntax: 

   ```java 

   if (condition) { 

       // Code to be executed if the condition is true 

   } else { 

       // Code to be executed if the condition is false 

   } 

   ``` 

  

3. **else-if ladder:** 

   - The `else-if` ladder allows checking multiple conditions one by one. If the condition is true, the corresponding block of code will be executed. If none of the conditions are true, the default else block (if present) will be executed. 

    

   Syntax: 

   ```java 

   if (condition1) { 

       // Code to be executed if condition1 is true 

   } else if (condition2) { 

       // Code to be executed if condition2 is true 

   } else if (condition3) { 

       // Code to be executed if condition3 is true 

   } else { 

       // Default code if no condition is true 

   } 

   ``` 

  

Example: 

  

```java 

int number = 10; 

  

// Example of if statement 

if (number > 0) { 

    System.out.println("Number is positive"); 

} 

  

// Example of if-else statement 

if (number > 0) { 

    System.out.println("Number is positive"); 

} else { 

    System.out.println("Number is not positive"); 

} 

  

// Example of else-if ladder 

if (number > 0) { 

    System.out.println("Number is positive"); 

} else if (number < 0) { 

    System.out.println("Number is negative"); 

} else { 

    System.out.println("Number is zero"); 

} 

``` 

  

These decision control structures help in writing programs that can make choices based on given conditions, allowing for dynamic behavior and more control over the flow of execution in Java programs. 

 

 

If Statement, IF ELSE statement, Nested If Statement 

 

 

 

`if` statement, `if-else` statement, and nested `if` statements in Java: 

  

### 1. If Statement: 

The `if` statement executes a block of code if the condition specified is true. 

  

Syntax: 

```java 

if (condition) { 

    // Code to execute if the condition is true 

} 

``` 

  

Example: 

```java 

int number = 10; 

  

// Example of if statement 

if (number > 0) { 

    System.out.println("Number is positive"); 

} 

``` 

  

### 2. If-Else Statement: 

The `if-else` statement executes one block of code if the condition is true and another block if the condition is false. 

  

Syntax: 

```java 

if (condition) { 

    // Code to execute if the condition is true 

} else { 

    // Code to execute if the condition is false 

} 

``` 

  

Example: 

```java 

int number = 10; 

  

// Example of if-else statement 

if (number > 0) { 

    System.out.println("Number is positive"); 

} else { 

    System.out.println("Number is not positive"); 

} 

``` 

  

### 3. Nested If Statement: 

Nested `if` statements contain an `if` statement within another `if` statement. This allows for more complex conditional logic. 

  

Syntax: 

```java 

if (condition1) { 

    // Code to execute if condition1 is true 

    if (condition2) { 

        // Code to execute if condition2 is true 

    } 

} 

``` 

  

Example: 

```java 

int x = 10; 

int y = 5; 

  

// Example of nested if statement 

if (x > 0) { 

    System.out.println("x is positive"); 

    if (y > 0) { 

        System.out.println("y is also positive"); 

    } 

} 

``` 

  

Nested `if` statements can have multiple levels, each level checking a specific condition.  

However, excessive nesting may lead to complex code and reduced readability, so it's essential to use them judiciously. 

 

Switch statement and the Tenary (?) operator 

 

 the `switch` statement and the ternary conditional operator (`? :`) in Java: 

  

### 1. Switch Statement: 

The `switch` statement is used to select one of many code blocks to be executed based on the value of a variable or expression. 

  

**Syntax:** 

```java 

switch (expression) { 

    case value1: 

        // Code to execute if expression equals value1 

        break; 

    case value2: 

        // Code to execute if expression equals value2 

        break; 

    // More cases... 

    default: 

        // Code to execute if expression doesn't match any case 

} 

``` 

  

**Example:** 

```java 

int day = 3; 

String dayName; 

  

// Example of switch statement to get the day name 

switch (day) { 

    case 1: 

        dayName = "Monday"; 

        break; 

    case 2: 

        dayName = "Tuesday"; 

        break; 

    case 3: 

        dayName = "Wednesday"; 

        break; 

    // More cases... 

    default: 

        dayName = "Invalid day"; 

} 

System.out.println("The day is: " + dayName); 

``` 

  

### 2. Ternary Operator (? :): 

The ternary operator `? :` is a concise way to express conditional statements. It evaluates a boolean expression and returns one of two values depending on the result of the evaluation. 

  

**Syntax:** 

```java 

result = (condition) ? valueIfTrue : valueIfFalse; 

``` 

  

**Example:** 

```java 

int x = 10; 

int y = 5; 

  

// Example of using the ternary operator 

String message = (x > y) ? "x is greater than y" : "y is greater than or equal to x"; 

System.out.println(message); 

``` 

  

The ternary operator evaluates the condition `(x > y)`. If the condition is true, it returns `"x is greater than y"`, otherwise, it returns `"y is greater than or equal to x"`. 

  

The `switch` statement allows for multiple conditional cases based on the value of an expression, while the ternary operator provides a concise way to create conditional expressions that return different values based on a condition.  

Both are useful tools for controlling the flow of execution in Java. 

 

 

# Day 5 Java Modifiers 

 

Java provides a number of access modifiers to set access levels for classes, variables, methods, and constructors. 

The four access levels are: 

Visible to the package, the default. No modifiers are needed. Visible to the class only (private). Visible to the world (public). Visible to the package and all subclasses (protected). 

Default Access Modifier - No Keyword 

Default access modifier means we do not explicitly declare an access modifier for a class, field, method, etc. A variable or method declared without any access control modifier is available to any other class in the same package. The fields in an interface are implicitly public static final and the methods in an interface are by default public. 

Example 

Variables and methods can be declared without any modifiers, as in the following an example: 

String version = "1.5.1"; boolean processOrder() { return true; } 

Private Access Modifier - Private 

Methods, variables, and constructors that are declared private can only be accessed within the declared class itself.Private access modifier is the most restrictive access level. Class and interfaces cannot be private. Variables that are declared private can be accessed outside the class, if public getter methods are present in the class. Using the private modifier is the main way that an object encapsulates itself and hides data from the outside world. 

                             Example 

The following class uses private access control 

public class Logger { private String format; 

public String getFormat() { return this.format; } 

public void setFormat(String format) { this.format = format; } } The format variable of the Logger class is private, so there's no way for other classes to retrieve or set its value directly. So, to make this variable available to the outside world, we defined two public methods: getFormat(), which returns the value of format, and setFormat(String), which sets its value. 

Public Access Modifier - Public 

A class, method, constructor, interface, etc. declared public can be accessed from any other class. Therefore, fields, methods, blocks declared inside a public class can be accessed from any class belonging to the Java Universe. 

However, if the public class we are trying to access is in a different package, then the public class still needs to be imported. Because of class inheritance, all public methods and variables of a class are inherited by its subclasses. 

Example 

The following function uses public access control: 

Public static void main(String[] arguments) { } The main() method of an application has to be public. Otherwise, it could not be called by a Java interpreter (such as java) to run the class. 

Protected Access Modifier - Protected 

Variables, methods, and constructors, which are declared protected in a superclass can be accessed only by the subclasses in other package or any class within the package of the protected members' class. The protected access modifier cannot be applied to class and interfaces. Methods, fields can be declared protected, however methods and fields in a interface cannot be declared protected. Protected access gives the subclass a chance to use the helper method or variable, while preventing a nonrelated class from trying to use it. 

Example 

The following parent class uses protected access control, to allow its child class override openSpeaker() method: class AudioPlayer { protected boolean openSpeaker(Speaker sp) { // implementation details } } 

class StreamingAudioPlayer extends AudioPlayer { boolean openSpeaker(Speaker sp) { // implementation details } } If we define openSpeaker() method as private, then it would not be accessible from any other class other than AudioPlayer. If we define it as public, then it would become accessible to all the outside world. But our intention is to expose this method to its subclass only, that's why we have used protected modifier. 

Access Control and Inheritance 

The following rules for inherited methods are enforced: 

Methods declared public in a superclass also must be public in all subclasses. 

Methods declared protected in a superclass must either be protected or public in subclasses; they cannot be private. 

Methods declared private are not inherited at all, so there is no rule for them. 

Example In this example, we've created a class with a private variable age and a variable with default scope as name. Using setter/getter method, we're updating age and getting value and name is updated directly. 

public class Puppy { private int age; String name; 

public Puppy() { 
} 

public void setAge( int age ) { this.age = age; } 

public int getAge( ) { return age; } 

public static void main(String []args) { Puppy myPuppy = new Puppy(); 

 // update age variable using method call 
  myPuppy.setAge( 2 ); 
 
  // update name directly 
  myPuppy.name = "Tommy"; 
  System.out.println("Age: " + myPuppy.getAge() +", name: " + myPuppy.name ); 
 

} } Output 


Introduction to Java 

Week 2 Day 1- Day 5 

 

Git 

 Version control systems track file changes over time and aid collaboration among developers. They manage code modifications through specialized databases. Services like GitHub, Bitbucket, and GitLab offer remote repositories for storing and sharing Git projects, with options ranging from free to commercial. 

What is Git? 

Git is an open-source distributed version control system ideal for projects of any size. I 

t's built for speed and efficiency, enabling seamless collaboration among developers within the same workspace.  

While it forms the foundation for services like GitHub and GitLab, Git can be used independently, both privately and publicly.  

Initially crafted by Linus Torvalds in 2005 for the Linux Kernel, Git boasts easy learning curves and rapid performance.  

Its capabilities surpass those of other SCM tools like Subversion, CVS, Perforce, and ClearCase. 

Benefits of Git. 

Git offers numerous advantages:  

1. Time Efficiency: Git operates swiftly, executing commands within seconds, saving considerable time compared to navigating through online interfaces. 

2. Offline Capability: It supports offline work, enabling local operations without reliance on constant internet connectivity, unlike some other CVS like SVN that depend on central repositories.  

3. Error Reversal: Git provides robust undo options, allowing for quick rectification of mistakes, serving as a safety net during development. 

4. Change Tracking: With features like Diff, Log, and Status, Git enables easy tracking of modifications, facilitating the review of file or branch status. 

 

Git tools. 

Git comes with various tools to enhance its functionality and user interface.  

Git Bash: This tool, available for Windows, emulates a Git command-line experience, offering a robust shell interface with essential commands like Ssh, scp, cat, find, and the entire set of Git core commands. 

Git GUI: It's a graphical version of Git's command line, providing visual diff tools for easier navigation and interaction with Git functionalities. It can be accessed via right-clicking on a folder or through a command line command like `$ git gui`. 

Gitk:This graphical history viewer acts as a shell over git log and git grep, aiding in visualizing project history and navigating past changes. Invoking it is as simple as typing `$ gitk [git log options]` in the command line within a Git repository. 

These tools within Git offer different interfaces to cater to diverse user preferences, making it more versatile and accessible for developers across various platforms and skill levels. 

Git Terminology. 

Certainly! Git terminology can be quite extensive, so here's an overview: 

  

- **Branch:** A distinct version of a repository that diverges from the main project. 

- **Checkout:** Switching between different versions of a target entity in Git. 

- **Cherry-Picking:** Selectively applying commits from one branch to another. 

- **Clone:** Creating a local copy of a repository from a remote URL. 

- **Fetch:** Updating remote-tracking branches with changes from other repositories. 

- **HEAD:** Represents the latest commit in the current branch. 

- **Index:** A staging area between the working directory and repository for preparing commits. 

- **Master:** The default and often primary branch in Git. 

- **Merge:** Integrating forked histories into a single branch. 

- Origin: A reference to the original repository from which a project was cloned. 

- Pull/Pull Request:Fetching and merging changes from a remote server, and a formal request to merge changes into a branch. 

- Push: Uploading local changes to a remote repository. 

- Rebase: Rearranging commits onto a new base commit. 

- Remote:The shared repository where team members exchange changes. 

- Repository: The structure storing file data and change history in Git. 

- Stashing:Temporarily saving incomplete work without committing. 

- Tag: Marking specific points in Git history as important references. 

- Upstream/Downstream: References to the original and integrated repositories. 

- Revert: Undoing specific commits. 

- Reset:Undoing changes with different modes (soft, mixed, hard). 

- Ignore: Specifying untracked files for Git to disregard. 

- Diff:Comparing differences between Git data sources. 

- Cheat Sheet: A quick reference summary of Git commands. 

- Git Flow: A branching model for collaborative development. 

- Squash: Combining multiple commits into one. 

- Rm: Removing tracked files from the Git index. 

- Fork: A duplicate copy of a repository, often used for testing and proposing changes. 

Day 3 

Basic commands of Git 

  

### Git Config 

```bash 

$ git config --global user.name "Your Name" 

$ git config --global user.email "youremail@example.com" 

``` 

  

### Git Init 

```bash 

$ git init 

``` 

  

### Git Clone 

```bash 

$ git clone repository_url 

``` 

  

### Git Add 

```bash 

$ git add filename 

$ git add * 

``` 

  

### Git Commit 

```bash 

$ git commit -m "Commit message" 

$ git commit -a 

``` 

  

### Git Status 

```bash 

$ git status 

``` 

  

### Git Push 

```bash 

$ git push origin master 

$ git push --all 

``` 

  

### Git Pull 

```bash 

$ git pull origin master 

``` 

  

### Git Branch 

```bash 

$ git branch 

``` 

  

### Git Merge 

```bash 

$ git merge branch_name 

``` 

 Git Log 

```bash 

$ git log 

$ git log -3 

``` 

Staging and commit 

 

Absolutely! Let's break down the major staging and committing operations in Git: 

### Git Add 

  

- **Purpose**: Adds file contents to the staging area, preparing them for the next commit. 

- **Usage**: 

  - To add a single file: `$ git add filename` 

  - To add all files: `$ git add -A` or `$ git add .` 

  - To add only updated and newly created files: `$ git add --ignore-removal` 

  - To add only modified and deleted files: `$ git add -u` 

  - To add files using wildcard: `$ git add *.java` 

  

### Git Commit 

  

- **Purpose**: Records changes in the repository by creating a commit. 

- **Usage**: 

  - Interactive commit message: `$ git commit` 

  - Committing all previously added files: `$ git commit -a` 

  - Adding a commit message: `$ git commit -m "Commit message"` 

  - Amending the last commit's message: `$ git commit --amend` 

  

### Git Clone 

  

- **Purpose**: Creates a local copy of a remote repository. 

- **Usage**: `$ git clone <repository URL>` 

  

### Git Fork 

  

- **Purpose**: Creates a copy of a repository, often used for proposing changes or experimenting without affecting the original project. 

- **Usage**: Done through the Git service platform (e.g., GitHub). Forking is not a Git command; it's a feature provided by Git service providers like GitHub. 

  

Day 4 

Inspect and Undo changes 

 

Git log is a vital tool in version control systems like Git, offering a comprehensive history of a repository's changes. It includes commit hashes, author details, commit dates, and commit messages. The following options enhance its functionality: 

  

### Basic Git Log 

```bash 

$ git log 

``` 

Displays recent commits with their unique identifiers, dates, authors, and commit details. 

  

### Git Log Stat 

```bash 

$ git log --stat 

``` 

Shows modified files, line additions/deletions, and a summary of changes. 

  

### Git Log Patch 

```bash 

$ git log -p 

``` 

Reveals modified files and the specific line changes made within those files. 

  

### Git Checkout 

Git checkout switches between different versions of a repository, be it files, commits, or branches. Careful when switching branches as it alters the working directory files to match the chosen branch. 

  

### Operations with Git Checkout 

- **Checkout Branch** 

```bash 

$ git checkout <branchname> 

``` 

Switches between branches. 

  

- **Create and Switch Branch** 

```bash 

$ git checkout -b <branchname> 

``` 

Creates and switches to a new branch simultaneously. 

  

- **Checkout Remote Branch** 

```bash 

$ git checkout <remotebranch> 

``` 

Allows accessing and working on a remote branch after fetching its contents. 

  

These commands aid in navigating and inspecting a repository's history, tracking changes, and managing branches efficiently in Git. 

Collaborating 

Sure, here's a simplified summary: 

  

### Git Fetch 

- **Purpose:** Downloads commits, objects, and refs from another repository. 

- **Usage:** 

  - `$ git fetch <repository URL>`: Fetches the complete repository. 

  - `$ git fetch <branch URL> <branch name>`: Fetches from a specific branch. 

  - `$ git fetch --all`: Fetches all branches simultaneously. 

  

### Git Pull / Pull Request 

- **Git Pull:** Receives data from a remote repository to update the local repository. 

  - Syntax: `$ git pull <option> [<repository URL> <refspec>...]` 

- **Pull Request:** Notifies team members of completed work for review and merging. 

  

### Git Push 

- **Purpose:** Uploads local repository content to a remote repository. 

- **Usage:**  

  - `$ git push <option> [<Remote URL> <branch name> <refspec>...]` 

  - `$ git push origin master`: Pushes local content to the master branch of the remote repository. 

- **Options:** Includes various options like `--all`, `--prune`, `--mirror`, `--dry-run`, `--tags`, `--delete`, `-u`. 

  

### Git Force Push 

- **Purpose:** Pushes local repository changes to the remote repository without conflict handling. 

- **Usage:** 

  - `$ git push <remote> <branch> -f` or `$ git push <remote> <branch> --force` 

  - `$ git push <remote> <branch> --force-with-lease` for a safe force push. 

  

### Delete a Remote Branch 

- **Purpose:** Removes a remote branch from the command line. 

- **Usage:** `$ git push origin --delete <branch name>` 

# WEEK3 day 1
## SDLCs
### what is SDLC?
The Software Development Life Cycle (SDLC) is a structured process that enables the production of high-quality, low-cost software, in the shortest possible production time. The goal of the SDLC is to produce superior software that meets and exceeds all customer expectations and demands.

#### steps of SDLC

The Software Development Life Cycle (SDLC) is a systematic process for planning, creating, testing, deploying, and maintaining information systems. The SDLC typically consists of seven phases, each with its own set of activities and deliverables. These phases provide a structured approach to software development, ensuring that the final product meets the requirements and expectations of stakeholders. The seven phases of the SDLC are as follows:

1. **Planning:**
   - Identify the scope, purpose, and objectives of the project.
   - Define project timelines, milestones, and resources.
   - Conduct feasibility studies and risk assessments.
   - Develop a project plan and obtain approvals.

2. **Feasibility Study:**
   - Assess the technical, operational, and economic feasibility of the project.
   - Identify potential risks and constraints.
   - Evaluate alternative solutions and select the most viable option.
   - Prepare a feasibility report for management approval.

3. **Design:**
   - Create a detailed design based on the requirements gathered during the planning phase.
   - Define system architecture, components, modules, and data structures.
   - Specify interfaces and interactions between system components.
   - Produce design documentation, including technical specifications.

4. **Implementation (Coding):**
   - Write code based on the detailed design specifications.
   - Follow coding standards and best practices.
   - Conduct unit testing to ensure individual components function as intended.
   - Debug and fix any defects found during testing.

5. **Testing:**
   - Conduct various testing activities to ensure the system meets the specified requirements.
   - Types of testing may include unit testing, integration testing, system testing, and user acceptance testing.
   - Identify and fix defects or issues discovered during testing.
   - Ensure that the software is reliable, secure, and performs as expected.

6. **Deployment (or Implementation):**
   - Deploy the software to the production environment.
   - Train end-users and support staff.
   - Monitor the system during the initial period of use.
   - Address any issues that arise during the deployment phase.

7. **Maintenance and Support:**
   - Provide ongoing support, maintenance, and updates to the software.
   - Address bug fixes and make enhancements based on user feedback.
   - Monitor the system's performance and security.
   - Evaluate the need for future updates or releases.
  
     # benefits of SDLC
-better management control over the entire development project
-transparency and visibility of all the processes
-clarity of requirements
-a single vision of a product for all the parties involved
-predictable results in terms of time, costs, and deliverables
-reduced risk of going off the track
