# intro_to_java
## week 1 day 1
Java is a high-level, object-oriented programming language that is designed to be platform-independent, meaning that Java programs can run on any device that has a Java Virtual Machine (JVM) installed.

## Advantages of Java:
1. Object-Oriented Programming (OOP): Java is a pure object-oriented programming language, which promotes code organization, reusability, and maintainability.

2. Strong Community Support: Java has a large and active community, which means there are extensive resources, libraries, and frameworks available. Developers can easily find support and solutions to their problems.

3. Scalability: Java is known for its scalability, making it suitable for building large-scale enterprise applications.

## disadvantages:

1. Performance: While the performance of Java has improved over the years, some low-level languages, like C or C++, may still offer better performance for certain types of applications.

2. Startup Time: Java applications may have a longer startup time compared to languages that are compiled to native code.

3. Learning Curve: Java's extensive ecosystem and libraries can make it challenging for beginners to learn the language quickly.

# java components

## java code(.java file)
 – this is the java code you have written, and its saved in the .java file(s)

## javac compiler:
 compile the source code files(.java) into a bytecode so that the jmv will be execute it.Bytecode is saved in a class file by compiler.

 ## Bytecode

 the resulting code after the source code has been executed by the compiler.

 ## Java Virtual Machine (JVM)

the primary function used to execute the bytecode produced by the compiler.

every os has its jvm, the output after execution of bytecode is the same accross all OS, that is why java is platform independent.

## steps to follow when executing a code
1. write a java program in an IDE with exwntion .java

2. the javac compiler is the primary compiler included in the JDK. It takes program as an input and convert it into java bytecode as an output

3. Java Virtual machine- it executes the bytecode generated by the compiler and this phase is called RUN PHASE.

## jdk 
complete Java development kit that includes JRE, compiler, and some more tools like javaDoc, java Debugger and more.
for you as a programmer you need to have JDK in order to be able to create java programs.

## JRE
 is the runtime environment required for running Java applications. It includes the JVM and other libraries that are needed for running Java programs but not for compiling them.

 # java Main features

 ## Platform Independence (Write Once, Run Anywhere):
 Java programs are compiled into bytecode, which is an intermediate form that can be executed on any device with a Java Virtual Machine (JVM).

## Object-Oriented: 
Java is designed around the principles of object-oriented programming (OOP). It supports concepts such as classes, objects, inheritance, polymorphism, and encapsulation, making it easy to organize and structure code.

## simple
 Java has a straightforward syntax, and its popularity has led to a large and active developer community. There are plenty of resources, tutorials, and forums available for learning and getting support.

## Robust language

when Java is described as a "robust" programming language, it refers to its ability to provide strong safeguards against errors and its capability to handle unexpected conditions gracefully.

## Security:
 Java has built-in security features, including a robust security model and a bytecode verifier, which helps ensure that code running on the JVM is safe and doesn't violate security constraints

## Multithreading:
 Java supports multithreading, allowing developers to write programs that can perform multiple tasks concurrently

 ## setting up the environment
etting up a Java development environment involves installing the Java Development Kit (JDK) and an Integrated Development Environment (IDE). Here are the steps to set up a basic Java environment:

1. Install the Java Development Kit (JDK):
## For Windows:
## Download JDK:
Visit the Oracle JDK download page or use an alternative like OpenJDK.

## Install JDK:
Follow the installation instructions provided on the download page.

## Set the PATH variable:
Add the JDK bin directory to your system's PATH variable. This allows you to run Java commands from any command prompt.

## java first program
public class firstProgram {
   public static void main(String[]args){
      System.out.println("hello world");
   }

} 


## First program Explained
public class HelloWorld {-: Every java application must have at least one class definition that consists of class keyword followed by classname. In this case classname is HelloWorld

public static void main (String[]args) {  this line is the main method. lets break the second line of code in our program to 
public : This makes the main method public that means that we can call the method from outside the class.

static : We do not need to create object for static methods to run. They can run itself.

void : It does not return anything.

main: It is the method name. This is the entry point method from which the JVM can run your program.

String [] args: Used for command line arguments that are passed as strings.

System.out println("Hello World"); -: This method prints the contents inside the double quotes into the console and inserts a newline after


# Structure of a java program
 
1. **Package Declaration:**
   Java programs often start with a package declaration. A package is a way to organize related classes. It is not mandatory, but it's good practice to include it. For example:

   ```java
   package com.example.myprogram;
   ```

2. **Import Statements:**
   After the package declaration, you may have import statements. These statements allow you to use classes from other packages without having to use their fully qualified names. For example:

   ```java
   import java.util.Scanner;
   ```

3. **Class Declaration:**
   A Java program must have at least one class, and the main class should have a `main` method where the program execution begins. The class name should match the filename (excluding the .java extension). For example:

   ```java
   public class Main {
       public static void main(String[] args) {
           // Program logic goes here
       }
   }
   ```

4. **Comments:**
   Comments are used to explain the code and are not executed by the compiler. They can be single-line (`//`) or multi-line (`/* */`). For example:

   ```java
   // This is a single-line comment

   /*
   This is a multi-line comment.
   It can span multiple lines.
   */
   ```

5. **Variables:**
   Declare variables to store data. Java is statically typed, so you need to specify the data type of each variable. For example:

   ```java
   int age = 25;
   String name = "John";
   ```

6. **Methods:**
   Methods are blocks of code that perform a specific task. The `main` method is the entry point of a Java program, and other methods are defined as needed. For example:

   ```java
   public static void main(String[] args) {
       // Program logic goes here
   }

   public static int addNumbers(int a, int b) {
       return a + b;
   }
   ```

7. **Control Flow Statements:**
   Use control flow statements like `if`, `else`, `while`, `for`, etc., to control the flow of execution in your program. For example:

   ```java
   if (condition) {
       // Code to execute if the condition is true
   } else {
       // Code to execute if the condition is false
   }

   for (int i = 0; i < 5; i++) {
       // Code to repeat multiple times
   }
   ```

8. **Object-Oriented Features:**
   Java is an object-oriented programming language, and programs often involve creating classes and objects. You might use concepts like inheritance, encapsulation, and polymorphism.

9. **Exception Handling:**
   Java provides exception handling with `try`, `catch`, `finally`, and `throw` statements to deal with runtime errors. For example:

   ```java
   try {
       // Code that might throw an exception
   } catch (Exception e) {
       // Code to handle the exception
   } finally {
       // Code that will be executed regardless of whether an exception occurs or not
   }
   ```

10. **Documentation:**
    It's a good practice to include documentation for your classes and methods using JavaDoc comments. For example:

    ```java
    /**
     * This is a JavaDoc comment for the MyClass class.
     */
    public class MyClass {
        /**
         * This is a JavaDoc comment for the myMethod method.
         * @param param1 Description of parameter 1
         * @param param2 Description of parameter 2
         * @return Description of the return value
         */
        public int myMethod(int param1, int param2) {
            // Method logic goes here
        }
    }
    ```

Remember, this is a basic structure, and the actual structure can vary based on the complexity and purpose of the program. It's also common to organize code into multiple classes and packages for larger projects.

# day2
 
What is a variable? 

A variable is a name given to a memory location. It is the basic unit of storage in a program. 

The value stored in a variable can be changed during program execution. 

A variable is only a name given to a memory location; all the operations done on the variable effects that memory location. 

In Java, all the variables must be declared before use. 

How to declare variables? 

type: Type of data that can be stored in this variable. 

name: Name given to the variable. 

It can be assigned values in two ways: 

Variable Initialization 

Assigning value by taking input. 

 

Declaring and initialize variables: 

datatype: Type of data that can be stored in this variable. 

variable_name: Name given to the variable. 

value: It is the initial value stored in the variable. 

Declaring variables examples 

float simpleInterest; - Declaring float variable 

int myAge = 19; - Declaring and Initializing integer variable 

char firstLetter = 'h'; - Declaring and Initializing character variable 

 

 

There are three types of variables in Java: 

 

Local Variables: A variable defined within a block or method or constructor is called local variable. 

Instance Variables: Instance variables are non-static variables and are declared in a class outside any method, constructor or block. 

Static Variables: Static variables are also known as Class variables. 

 

Data types in Java: 

1) Primitive data types - A primitive data type specifies the size and type of variable values, and it has no additional methods. 

2)  Non-primitive data types – Arrays and Strings are non-primitive data types, these are the datatypes which have instances like objects. Hence, they are called reference variables. They are primarily classes, arrays, strings or interfaces. 

 

There are eight primitive data types in Java: 

Byte 

Short 

Int 

Long 

Float 

Double 

Boolean 

Char 

# day 3 OOP

what is OOP?
OOP stands for Object-Oriented Programming, and it is a programming paradigm based on the concept of "objects." Java is a widely used object-oriented programming language, and it embodies the principles of OOP.

Key Concepts in Java OOP:
Class:

A class is a blueprint or template for creating objects. It defines attributes (fields) and behaviors (methods) that the objects will have.
Object:

An object is an instance of a class. It is a concrete realization of the class blueprint and represents a specific entity in the program.
Method:

A method is a function defined within a class. It represents the behavior or actions that objects of the class can perform.
Instance Variable:

An instance variable is a variable defined in a class and represents the state or properties of an object.
Constructor:

A constructor is a special method used for initializing objects when they are created. It has the same name as the class and is called automatically when an object is instantiated.
Java's support for OOP allows for the creation of modular, reusable, and maintainable code. The use of classes and objects facilitates the modeling of real-world entities and their interactions, making it easier to manage and understand complex systems.

# activity 1
Object-oriented programming (OOP) has become more popular than declarative and procedural programming for several reasons, and its popularity can be attributed to the following advantages:

Modularity and Reusability:

OOP promotes the concept of encapsulation, allowing the bundling of data and methods into a single unit (class). This leads to modular code, where each class represents a self-contained module with well-defined interfaces. This modularity facilitates code organization and makes it easier to reuse and maintain code components.
Code Reusability:

Inheritance in OOP allows for the creation of new classes that inherit properties and behaviors from existing classes. This promotes code reuse and reduces redundancy. Developers can extend existing classes to create new ones without rewriting the entire code.
Abstraction:

OOP provides abstraction, allowing developers to focus on the essential properties and behaviors of objects while hiding unnecessary details. Abstract classes and interfaces enable the creation of high-level, generalized blueprints that can be extended to create more specific implementations.
Encapsulation:

Encapsulation encapsulates the implementation details within a class, exposing only necessary interfaces to the outside world. This reduces the complexity of the code, improves maintainability, and minimizes the risk of unintended interference with the internal workings of a class.

Flexibility and Extensibility:

OOP languages support polymorphism, allowing objects of different types to be treated as objects of a common type. This flexibility enables the development of generic and extensible code, making it easier to adapt to changing requirements.
Modeling Real-World Concepts:

OOP is well-suited for modeling and simulating real-world entities and their relationships. Concepts like objects, classes, and inheritance closely align with how we think about and categorize things in the real world. This makes OOP a natural choice for applications where the goal is to model and represent complex systems.
Collaborative Development:

OOP encourages the creation of well-defined interfaces and contracts between different parts of a program. This helps in collaborative development, where teams can work on different parts of a system independently as long as they adhere to the specified interfaces.
Graphical User Interface (GUI) Development:

OOP is often the preferred paradigm for developing graphical user interfaces. The concept of objects representing visual elements and their interactions aligns well with GUI design principles.

# Features of OOP – Core features

1.Encapsulation
2. polymorphism
3. inheritance
4. abstraction

### Encapsulation:
Encapsulation refers to the bundling of data (attributes) and methods (functions) that operate on the data into a single unit known as a class. A class serves as a blueprint for creating objects, and it encapsulates the internal details of how an object works.

### Polymorphism:
Polymorphism allows objects of different types to be treated as objects of a common type. There are two types of polymorphism in Java: compile-time polymorphism (method overloading) and runtime polymorphism (method overriding). Polymorphism makes it possible to write more generic and reusable code.

### Inheritance:

Inheritance allows a class (subclass or derived class) to inherit the properties and behaviors of another class (superclass or base class). This promotes code reuse and establishes a hierarchy of classes, where a subclass can extend or override the functionality of its superclass.

### Abstraction:
Abstraction involves simplifying complex systems by modeling classes based on the essential properties and behaviors relevant to the problem. It allows programmers to focus on what an object does rather than how it achieves its functionality. Abstract classes and interfaces are used to achieve abstraction in Java.

# activity 2
Here are the three Java classes based on the provided information:

1. **PurchaseItem Class:**
   ```java
   public class PurchaseItem {
       private String name;
       private double unitPrice;

       // Constructor to initialize instance variables
       public PurchaseItem(String name, double unitPrice) {
           this.name = name;
           this.unitPrice = unitPrice;
       }

       // Default constructor
       public PurchaseItem() {
           this.name = "no item";
           this.unitPrice = 0;
       }

       // Method to get the unit price
       public double getPrice() {
           return unitPrice;
       }
   }
   ```

2. **WeighedItem Class (Subclass of PurchaseItem):**
   ```java
   public class WeighedItem extends PurchaseItem {
       private double weight;

       // Constructor using superclass constructor
       public WeighedItem(String name, double unitPrice, double weight) {
           super(name, unitPrice);
           this.weight = weight;
       }

       // Override getPrice method
       @Override
       public double getPrice() {
           // Calculate the price based on unit price and weight
           return super.getPrice() * weight;
       }
   }
   ```

3. **CountedItem Class (Subclass of PurchaseItem):**
   ```java
   public class CountedItem extends PurchaseItem {
       private int quantity;

       // Constructor using superclass constructor
       public CountedItem(String name, double unitPrice, int quantity) {
           super(name, unitPrice);
           this.quantity = quantity;
       }

       // Override getPrice method
       @Override
       public double getPrice() {
           // Calculate the price based on unit price and quantity
           return super.getPrice() * quantity;
       }
   }
   ```

Example of using these classes:

```java
public class Main {
    public static void main(String[] args) {
        // Example of WeighedItem
        WeighedItem banana = new WeighedItem("Banana", 3.00, 1.37);
        System.out.println(banana.getName() + " @ " + banana.getPrice() + " R" + banana.getPrice());

        // Example of CountedItem
        CountedItem pens = new CountedItem("Pens", 4.5, 10);
        System.out.println(pens.getName() + " @ " + pens.getPrice() + " R" + pens.getPrice());
    }
}
```

In this example, the `WeighedItem` and `CountedItem` classes extend the `PurchaseItem` class. The `getPrice` method is overridden in each subclass to calculate the total price based on the specific properties of that item (weight or quantity). The `super.getPrice()` call is used to access the `getPrice` method of the superclass.

# Features of OOP – Other features

 coupling, cohesion, association, aggregation, and composition—additional concepts related to object-oriented design and programming.

1. **Coupling:**
   - **Definition:** Coupling refers to the degree of dependence between classes or modules. It measures how much one class knows about another. Low coupling is desirable as it leads to more maintainable and flexible systems.
   - **Types:**
     - **Low Coupling:** Classes have minimal knowledge of each other. Changes in one class have minimal impact on others.
     - **High Coupling:** Classes are closely connected, and changes in one class may require changes in others.

2. **Cohesion:**
   - **Definition:** Cohesion measures how closely the elements within a module (class or method) are related to each other. High cohesion is desirable as it leads to more maintainable and understandable code.
   - **Types:**
     - **High Cohesion:** Elements within a module are closely related and work together to achieve a common goal.
     - **Low Cohesion:** Elements within a module have weak relationships and may not contribute to a common goal.

3. **Association:**
   - **Definition:** Association represents a bi-directional relationship between two classes. It can be a one-to-one, one-to-many, or many-to-many relationship.
   - **Example:** In a university system, a `Student` class may be associated with a `Course` class through enrollment.

4. **Aggregation:**
   - **Definition:** Aggregation is a special form of association representing a "whole-part" relationship between classes. It implies that one class (the whole) contains another class (the part), but the part can exist independently.
   - **Example:** In a car example, a `Car` class may have an aggregation relationship with a `Wheel` class. A `Car` has wheels, and wheels can exist independently.

5. **Composition:**
   - **Definition:** Composition is a stronger form of aggregation, where the part cannot exist independently of the whole. If the whole is destroyed, all its parts are destroyed as well.
   - **Example:** In a computer example, a `Computer` class may have a composition relationship with a `CPU` class. If the `Computer` is destroyed, the `CPU` is also destroyed.

Understanding these concepts is crucial for designing systems with maintainability, flexibility, and clarity in mind. Properly managing coupling and cohesion helps create systems that are easier to modify and extend. Meanwhile, understanding association, aggregation, and composition allows for modeling real-world relationships more accurately in your code.

## activity 3
Certainly! Below are three Java classes, `Company`, `Store`, and `Product`, demonstrating the relationships using association and aggregation:

1. **Product Class:**
   ```java
   public class Product {
       private String name;
       private int quantity;
       private double price;

       // Constructor
       public Product(String name, int quantity, double price) {
           this.name = name;
           this.quantity = quantity;
           this.price = price;
       }

       // Getters and Setters (not shown for brevity)
   }
   ```

2. **Store Class (Aggregation with Product):**
   ```java
   import java.util.ArrayList;
   import java.util.List;

   public class Store {
       private String name;
       private String location;
       private List<Product> productList;

       // Constructor
       public Store(String name, String location) {
           this.name = name;
           this.location = location;
           this.productList = new ArrayList<>();
       }

       // Aggregation: Adding a Product to the ProductList
       public void addProduct(Product product) {
           productList.add(product);
       }

       // Getters and Setters (not shown for brevity)
   }
   ```

3. **Company Class (Association with Store):**
   ```java
   import java.util.ArrayList;
   import java.util.List;

   public class Company {
       private String name;
       private List<Store> storeList;

       // Constructor
       public Company(String name) {
           this.name = name;
           this.storeList = new ArrayList<>();
       }

       // Association: Adding a Store to the StoreList
       public void addStore(Store store) {
           storeList.add(store);
       }

       // Getters and Setters (not shown for brevity)
   }
   ```

In the above demo:

- The `Product` class represents a product with attributes such as name, quantity, and price.
- The `Store` class represents a store with attributes like name, location, and a list of products. The relationship with `Product` is aggregation, as a store contains products, and products can exist independently.
- The `Company` class represents a company with a name and a list of stores. The relationship with `Store` is association, as a company is associated with multiple stores.


# Day 4 

## Introduction to Decision control 

 

Decision control in Java refers to the programming constructs that allow you to control the flow of execution based on certain conditions or decisions.  

 

### There are mainly three decision-making structures in Java: 

  

1. if statement: 

   - The `if` statement evaluates a boolean expression and executes a block of code only if the condition is true. 

    

   Syntax: 

   ```java 

   if (condition) { 

       // Code to be executed if the condition is true 

   } 

   ``` 

  

2. **if-else statement:** 

   - The `if-else` statement allows the program to execute one block of code if the condition is true and another block if the condition is false. 

    

   Syntax: 

   ```java 

   if (condition) { 

       // Code to be executed if the condition is true 

   } else { 

       // Code to be executed if the condition is false 

   } 

   ``` 

  

3. **else-if ladder:** 

   - The `else-if` ladder allows checking multiple conditions one by one. If the condition is true, the corresponding block of code will be executed. If none of the conditions are true, the default else block (if present) will be executed. 

    

   Syntax: 

   ```java 

   if (condition1) { 

       // Code to be executed if condition1 is true 

   } else if (condition2) { 

       // Code to be executed if condition2 is true 

   } else if (condition3) { 

       // Code to be executed if condition3 is true 

   } else { 

       // Default code if no condition is true 

   } 

   ``` 

  

Example: 

  

```java 

int number = 10; 

  

// Example of if statement 

if (number > 0) { 

    System.out.println("Number is positive"); 

} 

  

// Example of if-else statement 

if (number > 0) { 

    System.out.println("Number is positive"); 

} else { 

    System.out.println("Number is not positive"); 

} 

  

// Example of else-if ladder 

if (number > 0) { 

    System.out.println("Number is positive"); 

} else if (number < 0) { 

    System.out.println("Number is negative"); 

} else { 

    System.out.println("Number is zero"); 

} 

``` 

  

These decision control structures help in writing programs that can make choices based on given conditions, allowing for dynamic behavior and more control over the flow of execution in Java programs. 

 

 

If Statement, IF ELSE statement, Nested If Statement 

 

 

 

`if` statement, `if-else` statement, and nested `if` statements in Java: 

  

### 1. If Statement: 

The `if` statement executes a block of code if the condition specified is true. 

  

Syntax: 

```java 

if (condition) { 

    // Code to execute if the condition is true 

} 

``` 

  

Example: 

```java 

int number = 10; 

  

// Example of if statement 

if (number > 0) { 

    System.out.println("Number is positive"); 

} 

``` 

  

### 2. If-Else Statement: 

The `if-else` statement executes one block of code if the condition is true and another block if the condition is false. 

  

Syntax: 

```java 

if (condition) { 

    // Code to execute if the condition is true 

} else { 

    // Code to execute if the condition is false 

} 

``` 

  

Example: 

```java 

int number = 10; 

  

// Example of if-else statement 

if (number > 0) { 

    System.out.println("Number is positive"); 

} else { 

    System.out.println("Number is not positive"); 

} 

``` 

  

### 3. Nested If Statement: 

Nested `if` statements contain an `if` statement within another `if` statement. This allows for more complex conditional logic. 

  

Syntax: 

```java 

if (condition1) { 

    // Code to execute if condition1 is true 

    if (condition2) { 

        // Code to execute if condition2 is true 

    } 

} 

``` 

  

Example: 

```java 

int x = 10; 

int y = 5; 

  

// Example of nested if statement 

if (x > 0) { 

    System.out.println("x is positive"); 

    if (y > 0) { 

        System.out.println("y is also positive"); 

    } 

} 

``` 

  

Nested `if` statements can have multiple levels, each level checking a specific condition.  

However, excessive nesting may lead to complex code and reduced readability, so it's essential to use them judiciously. 

 

Switch statement and the Tenary (?) operator 

 

 the `switch` statement and the ternary conditional operator (`? :`) in Java: 

  

### 1. Switch Statement: 

The `switch` statement is used to select one of many code blocks to be executed based on the value of a variable or expression. 

  

**Syntax:** 

```java 

switch (expression) { 

    case value1: 

        // Code to execute if expression equals value1 

        break; 

    case value2: 

        // Code to execute if expression equals value2 

        break; 

    // More cases... 

    default: 

        // Code to execute if expression doesn't match any case 

} 

``` 

  

**Example:** 

```java 

int day = 3; 

String dayName; 

  

// Example of switch statement to get the day name 

switch (day) { 

    case 1: 

        dayName = "Monday"; 

        break; 

    case 2: 

        dayName = "Tuesday"; 

        break; 

    case 3: 

        dayName = "Wednesday"; 

        break; 

    // More cases... 

    default: 

        dayName = "Invalid day"; 

} 

System.out.println("The day is: " + dayName); 

``` 

  

### 2. Ternary Operator (? :): 

The ternary operator `? :` is a concise way to express conditional statements. It evaluates a boolean expression and returns one of two values depending on the result of the evaluation. 

  

**Syntax:** 

```java 

result = (condition) ? valueIfTrue : valueIfFalse; 

``` 

  

**Example:** 

```java 

int x = 10; 

int y = 5; 

  

// Example of using the ternary operator 

String message = (x > y) ? "x is greater than y" : "y is greater than or equal to x"; 

System.out.println(message); 

``` 

  

The ternary operator evaluates the condition `(x > y)`. If the condition is true, it returns `"x is greater than y"`, otherwise, it returns `"y is greater than or equal to x"`. 

  

The `switch` statement allows for multiple conditional cases based on the value of an expression, while the ternary operator provides a concise way to create conditional expressions that return different values based on a condition.  

Both are useful tools for controlling the flow of execution in Java. 

 

 

# Day 5 Java Modifiers 

 

Java provides a number of access modifiers to set access levels for classes, variables, methods, and constructors. 

The four access levels are: 

Visible to the package, the default. No modifiers are needed. Visible to the class only (private). Visible to the world (public). Visible to the package and all subclasses (protected). 

Default Access Modifier - No Keyword 

Default access modifier means we do not explicitly declare an access modifier for a class, field, method, etc. A variable or method declared without any access control modifier is available to any other class in the same package. The fields in an interface are implicitly public static final and the methods in an interface are by default public. 

Example 

Variables and methods can be declared without any modifiers, as in the following an example: 

String version = "1.5.1"; boolean processOrder() { return true; } 

Private Access Modifier - Private 

Methods, variables, and constructors that are declared private can only be accessed within the declared class itself.Private access modifier is the most restrictive access level. Class and interfaces cannot be private. Variables that are declared private can be accessed outside the class, if public getter methods are present in the class. Using the private modifier is the main way that an object encapsulates itself and hides data from the outside world. 

                             Example 

The following class uses private access control 

public class Logger { private String format; 

public String getFormat() { return this.format; } 

public void setFormat(String format) { this.format = format; } } The format variable of the Logger class is private, so there's no way for other classes to retrieve or set its value directly. So, to make this variable available to the outside world, we defined two public methods: getFormat(), which returns the value of format, and setFormat(String), which sets its value. 

Public Access Modifier - Public 

A class, method, constructor, interface, etc. declared public can be accessed from any other class. Therefore, fields, methods, blocks declared inside a public class can be accessed from any class belonging to the Java Universe. 

However, if the public class we are trying to access is in a different package, then the public class still needs to be imported. Because of class inheritance, all public methods and variables of a class are inherited by its subclasses. 

Example 

The following function uses public access control: 

Public static void main(String[] arguments) { } The main() method of an application has to be public. Otherwise, it could not be called by a Java interpreter (such as java) to run the class. 

Protected Access Modifier - Protected 

Variables, methods, and constructors, which are declared protected in a superclass can be accessed only by the subclasses in other package or any class within the package of the protected members' class. The protected access modifier cannot be applied to class and interfaces. Methods, fields can be declared protected, however methods and fields in a interface cannot be declared protected. Protected access gives the subclass a chance to use the helper method or variable, while preventing a nonrelated class from trying to use it. 

Example 

The following parent class uses protected access control, to allow its child class override openSpeaker() method: class AudioPlayer { protected boolean openSpeaker(Speaker sp) { // implementation details } } 

class StreamingAudioPlayer extends AudioPlayer { boolean openSpeaker(Speaker sp) { // implementation details } } If we define openSpeaker() method as private, then it would not be accessible from any other class other than AudioPlayer. If we define it as public, then it would become accessible to all the outside world. But our intention is to expose this method to its subclass only, that's why we have used protected modifier. 

Access Control and Inheritance 

The following rules for inherited methods are enforced: 

Methods declared public in a superclass also must be public in all subclasses. 

Methods declared protected in a superclass must either be protected or public in subclasses; they cannot be private. 

Methods declared private are not inherited at all, so there is no rule for them. 

Example In this example, we've created a class with a private variable age and a variable with default scope as name. Using setter/getter method, we're updating age and getting value and name is updated directly. 

public class Puppy { private int age; String name; 

public Puppy() { 
} 

public void setAge( int age ) { this.age = age; } 

public int getAge( ) { return age; } 

public static void main(String []args) { Puppy myPuppy = new Puppy(); 

 // update age variable using method call 
  myPuppy.setAge( 2 ); 
 
  // update name directly 
  myPuppy.name = "Tommy"; 
  System.out.println("Age: " + myPuppy.getAge() +", name: " + myPuppy.name ); 
 

} } Output 


Introduction to Java 

Week 2 Day 1- Day 5 

 

Git 

 Version control systems track file changes over time and aid collaboration among developers. They manage code modifications through specialized databases. Services like GitHub, Bitbucket, and GitLab offer remote repositories for storing and sharing Git projects, with options ranging from free to commercial. 

What is Git? 

Git is an open-source distributed version control system ideal for projects of any size. I 

t's built for speed and efficiency, enabling seamless collaboration among developers within the same workspace.  

While it forms the foundation for services like GitHub and GitLab, Git can be used independently, both privately and publicly.  

Initially crafted by Linus Torvalds in 2005 for the Linux Kernel, Git boasts easy learning curves and rapid performance.  

Its capabilities surpass those of other SCM tools like Subversion, CVS, Perforce, and ClearCase. 

Benefits of Git. 

Git offers numerous advantages:  

1. Time Efficiency: Git operates swiftly, executing commands within seconds, saving considerable time compared to navigating through online interfaces. 

2. Offline Capability: It supports offline work, enabling local operations without reliance on constant internet connectivity, unlike some other CVS like SVN that depend on central repositories.  

3. Error Reversal: Git provides robust undo options, allowing for quick rectification of mistakes, serving as a safety net during development. 

4. Change Tracking: With features like Diff, Log, and Status, Git enables easy tracking of modifications, facilitating the review of file or branch status. 

 

Git tools. 

Git comes with various tools to enhance its functionality and user interface.  

Git Bash: This tool, available for Windows, emulates a Git command-line experience, offering a robust shell interface with essential commands like Ssh, scp, cat, find, and the entire set of Git core commands. 

Git GUI: It's a graphical version of Git's command line, providing visual diff tools for easier navigation and interaction with Git functionalities. It can be accessed via right-clicking on a folder or through a command line command like `$ git gui`. 

Gitk:This graphical history viewer acts as a shell over git log and git grep, aiding in visualizing project history and navigating past changes. Invoking it is as simple as typing `$ gitk [git log options]` in the command line within a Git repository. 

These tools within Git offer different interfaces to cater to diverse user preferences, making it more versatile and accessible for developers across various platforms and skill levels. 

Git Terminology. 

Certainly! Git terminology can be quite extensive, so here's an overview: 

  

- **Branch:** A distinct version of a repository that diverges from the main project. 

- **Checkout:** Switching between different versions of a target entity in Git. 

- **Cherry-Picking:** Selectively applying commits from one branch to another. 

- **Clone:** Creating a local copy of a repository from a remote URL. 

- **Fetch:** Updating remote-tracking branches with changes from other repositories. 

- **HEAD:** Represents the latest commit in the current branch. 

- **Index:** A staging area between the working directory and repository for preparing commits. 

- **Master:** The default and often primary branch in Git. 

- **Merge:** Integrating forked histories into a single branch. 

- Origin: A reference to the original repository from which a project was cloned. 

- Pull/Pull Request:Fetching and merging changes from a remote server, and a formal request to merge changes into a branch. 

- Push: Uploading local changes to a remote repository. 

- Rebase: Rearranging commits onto a new base commit. 

- Remote:The shared repository where team members exchange changes. 

- Repository: The structure storing file data and change history in Git. 

- Stashing:Temporarily saving incomplete work without committing. 

- Tag: Marking specific points in Git history as important references. 

- Upstream/Downstream: References to the original and integrated repositories. 

- Revert: Undoing specific commits. 

- Reset:Undoing changes with different modes (soft, mixed, hard). 

- Ignore: Specifying untracked files for Git to disregard. 

- Diff:Comparing differences between Git data sources. 

- Cheat Sheet: A quick reference summary of Git commands. 

- Git Flow: A branching model for collaborative development. 

- Squash: Combining multiple commits into one. 

- Rm: Removing tracked files from the Git index. 

- Fork: A duplicate copy of a repository, often used for testing and proposing changes. 

Day 3 

Basic commands of Git 

  

### Git Config 

```bash 

$ git config --global user.name "Your Name" 

$ git config --global user.email "youremail@example.com" 

``` 

  

### Git Init 

```bash 

$ git init 

``` 

  

### Git Clone 

```bash 

$ git clone repository_url 

``` 

  

### Git Add 

```bash 

$ git add filename 

$ git add * 

``` 

  

### Git Commit 

```bash 

$ git commit -m "Commit message" 

$ git commit -a 

``` 

  

### Git Status 

```bash 

$ git status 

``` 

  

### Git Push 

```bash 

$ git push origin master 

$ git push --all 

``` 

  

### Git Pull 

```bash 

$ git pull origin master 

``` 

  

### Git Branch 

```bash 

$ git branch 

``` 

  

### Git Merge 

```bash 

$ git merge branch_name 

``` 

 Git Log 

```bash 

$ git log 

$ git log -3 

``` 

Staging and commit 

 

Absolutely! Let's break down the major staging and committing operations in Git: 

### Git Add 

  

- **Purpose**: Adds file contents to the staging area, preparing them for the next commit. 

- **Usage**: 

  - To add a single file: `$ git add filename` 

  - To add all files: `$ git add -A` or `$ git add .` 

  - To add only updated and newly created files: `$ git add --ignore-removal` 

  - To add only modified and deleted files: `$ git add -u` 

  - To add files using wildcard: `$ git add *.java` 

  

### Git Commit 

  

- **Purpose**: Records changes in the repository by creating a commit. 

- **Usage**: 

  - Interactive commit message: `$ git commit` 

  - Committing all previously added files: `$ git commit -a` 

  - Adding a commit message: `$ git commit -m "Commit message"` 

  - Amending the last commit's message: `$ git commit --amend` 

  

### Git Clone 

  

- **Purpose**: Creates a local copy of a remote repository. 

- **Usage**: `$ git clone <repository URL>` 

  

### Git Fork 

  

- **Purpose**: Creates a copy of a repository, often used for proposing changes or experimenting without affecting the original project. 

- **Usage**: Done through the Git service platform (e.g., GitHub). Forking is not a Git command; it's a feature provided by Git service providers like GitHub. 

  

Day 4 

Inspect and Undo changes 

 

Git log is a vital tool in version control systems like Git, offering a comprehensive history of a repository's changes. It includes commit hashes, author details, commit dates, and commit messages. The following options enhance its functionality: 

  

### Basic Git Log 

```bash 

$ git log 

``` 

Displays recent commits with their unique identifiers, dates, authors, and commit details. 

  

### Git Log Stat 

```bash 

$ git log --stat 

``` 

Shows modified files, line additions/deletions, and a summary of changes. 

  

### Git Log Patch 

```bash 

$ git log -p 

``` 

Reveals modified files and the specific line changes made within those files. 

  

### Git Checkout 

Git checkout switches between different versions of a repository, be it files, commits, or branches. Careful when switching branches as it alters the working directory files to match the chosen branch. 

  

### Operations with Git Checkout 

- **Checkout Branch** 

```bash 

$ git checkout <branchname> 

``` 

Switches between branches. 

  

- **Create and Switch Branch** 

```bash 

$ git checkout -b <branchname> 

``` 

Creates and switches to a new branch simultaneously. 

  

- **Checkout Remote Branch** 

```bash 

$ git checkout <remotebranch> 

``` 

Allows accessing and working on a remote branch after fetching its contents. 

  

These commands aid in navigating and inspecting a repository's history, tracking changes, and managing branches efficiently in Git. 

Collaborating 

Sure, here's a simplified summary: 

  

### Git Fetch 

- **Purpose:** Downloads commits, objects, and refs from another repository. 

- **Usage:** 

  - `$ git fetch <repository URL>`: Fetches the complete repository. 

  - `$ git fetch <branch URL> <branch name>`: Fetches from a specific branch. 

  - `$ git fetch --all`: Fetches all branches simultaneously. 

  

### Git Pull / Pull Request 

- **Git Pull:** Receives data from a remote repository to update the local repository. 

  - Syntax: `$ git pull <option> [<repository URL> <refspec>...]` 

- **Pull Request:** Notifies team members of completed work for review and merging. 

  

### Git Push 

- **Purpose:** Uploads local repository content to a remote repository. 

- **Usage:**  

  - `$ git push <option> [<Remote URL> <branch name> <refspec>...]` 

  - `$ git push origin master`: Pushes local content to the master branch of the remote repository. 

- **Options:** Includes various options like `--all`, `--prune`, `--mirror`, `--dry-run`, `--tags`, `--delete`, `-u`. 

  

### Git Force Push 

- **Purpose:** Pushes local repository changes to the remote repository without conflict handling. 

- **Usage:** 

  - `$ git push <remote> <branch> -f` or `$ git push <remote> <branch> --force` 

  - `$ git push <remote> <branch> --force-with-lease` for a safe force push. 

  

### Delete a Remote Branch 

- **Purpose:** Removes a remote branch from the command line. 

- **Usage:** `$ git push origin --delete <branch name>` 

# WEEK3 day 1
## SDLCs
### what is SDLC?
The Software Development Life Cycle (SDLC) is a structured process that enables the production of high-quality, low-cost software, in the shortest possible production time. The goal of the SDLC is to produce superior software that meets and exceeds all customer expectations and demands.

#### steps of SDLC

The Software Development Life Cycle (SDLC) is a systematic process for planning, creating, testing, deploying, and maintaining information systems. The SDLC typically consists of seven phases, each with its own set of activities and deliverables. These phases provide a structured approach to software development, ensuring that the final product meets the requirements and expectations of stakeholders. The seven phases of the SDLC are as follows:

1. **Planning:**
   - Identify the scope, purpose, and objectives of the project.
   - Define project timelines, milestones, and resources.
   - Conduct feasibility studies and risk assessments.
   - Develop a project plan and obtain approvals.

2. **Feasibility Study:**
   - Assess the technical, operational, and economic feasibility of the project.
   - Identify potential risks and constraints.
   - Evaluate alternative solutions and select the most viable option.
   - Prepare a feasibility report for management approval.

3. **Design:**
   - Create a detailed design based on the requirements gathered during the planning phase.
   - Define system architecture, components, modules, and data structures.
   - Specify interfaces and interactions between system components.
   - Produce design documentation, including technical specifications.

4. **Implementation (Coding):**
   - Write code based on the detailed design specifications.
   - Follow coding standards and best practices.
   - Conduct unit testing to ensure individual components function as intended.
   - Debug and fix any defects found during testing.

5. **Testing:**
   - Conduct various testing activities to ensure the system meets the specified requirements.
   - Types of testing may include unit testing, integration testing, system testing, and user acceptance testing.
   - Identify and fix defects or issues discovered during testing.
   - Ensure that the software is reliable, secure, and performs as expected.

6. **Deployment (or Implementation):**
   - Deploy the software to the production environment.
   - Train end-users and support staff.
   - Monitor the system during the initial period of use.
   - Address any issues that arise during the deployment phase.

7. **Maintenance and Support:**
   - Provide ongoing support, maintenance, and updates to the software.
   - Address bug fixes and make enhancements based on user feedback.
   - Monitor the system's performance and security.
   - Evaluate the need for future updates or releases.
  
     # benefits of SDLC
-better management control over the entire development project
-transparency and visibility of all the processes
-clarity of requirements
-a single vision of a product for all the parties involved
-predictable results in terms of time, costs, and deliverables
-reduced risk of going off the track
# SDLC models
SDLC - Waterfall Model
The Waterfall Model was the first Process Model to be introduced. It is also referred to as a linear-sequential life cycle model. It is very simple to understand and use. In a waterfall model, each phase must be completed before the next phase can begin and there is no overlapping in the phases.

The Waterfall model is the earliest SDLC approach that was used for software development.

The waterfall Model illustrates the software development process in a linear sequential flow. This means that any phase in the development process begins only if the previous phase is complete. In this waterfall model, the phases do not overlap.

Waterfall Model - Design
Waterfall approach was first SDLC Model to be used widely in Software Engineering to ensure success of the project. In "The Waterfall" approach, the whole process of software development is divided into separate phases. In this Waterfall model, typically, the outcome of one phase acts as the input for the next phase sequentially.

### The following illustration is a representation of the different phases of the Waterfall Model.

## SDLC Waterfall Model

The sequential phases in Waterfall model are −

Requirement Gathering and analysis − All possible requirements of the system to be developed are captured in this phase and documented in a requirement specification document.

System Design − The requirement specifications from first phase are studied in this phase and the system design is prepared. This system design helps in specifying hardware and system requirements and helps in defining the overall system architecture.

Implementation − With inputs from the system design, the system is first developed in small programs called units, which are integrated in the next phase. Each unit is developed and tested for its functionality, which is referred to as Unit Testing.

Integration and Testing − All the units developed in the implementation phase are integrated into a system after testing of each unit. Post integration the entire system is tested for any faults and failures.

Deployment of system − Once the functional and non-functional testing is done; the product is deployed in the customer environment or released into the market.

Maintenance − There are some issues which come up in the client environment. To fix those issues, patches are released. Also to enhance the product some better versions are released. Maintenance is done to deliver these changes in the customer environment.

All these phases are cascaded to each other in which progress is seen as flowing steadily downwards (like a waterfall) through the phases. The next phase is started only after the defined set of goals are achieved for previous phase and it is signed off, so the name "Waterfall Model". In this model, phases do not overlap.

## Waterfall Model - Application
Every software developed is different and requires a suitable SDLC approach to be followed based on the internal and external factors. Some situations where the use of Waterfall model is most appropriate are −

Requirements are very well documented, clear and fixed.

Product definition is stable.

Technology is understood and is not dynamic.

There are no ambiguous requirements.

Ample resources with required expertise are available to support the product.

The project is short.

#### Waterfall Model - Advantages
The advantages of waterfall development are that it allows for departmentalization and control. A schedule can be set with deadlines for each stage of development and a product can proceed through the development process model phases one by one.

Development moves from concept, through design, implementation, testing, installation, troubleshooting, and ends up at operation and maintenance. Each phase of development proceeds in strict order.

Some of the major advantages of the Waterfall Model are as follows −

Simple and easy to understand and use

Easy to manage due to the rigidity of the model. Each phase has specific deliverables and a review process.

Phases are processed and completed one at a time.

Works well for smaller projects where requirements are very well understood.

Clearly defined stages.

Well understood milestones.

Easy to arrange tasks.

Process and results are well documented.


#### Waterfall Model - Disadvantages
The disadvantage of waterfall development is that it does not allow much reflection or revision. Once an application is in the testing stage, it is very difficult to go back and change something that was not well-documented or thought upon in the concept stage.

The major disadvantages of the Waterfall Model are as follows −

No working software is produced until late during the life cycle.

High amounts of risk and uncertainty.

Not a good model for complex and object-oriented projects.

Poor model for long and ongoing projects.

Not suitable for the projects where requirements are at a moderate to high risk of changing. So, risk and uncertainty is high with this process model.

It is difficult to measure progress within stages.

Cannot accommodate changing requirements.

Adjusting scope during the life cycle can end a project.

Integration is done as a "big-bang. at the very end, which doesn't allow identifying any technological or business bottleneck or challenges early.

### SDLC - Iterative Model
In the Iterative model, iterative process starts with a simple implementation of a small set of the software requirements and iteratively enhances the evolving versions until the complete system is implemented and ready to be deployed.

An iterative life cycle model does not attempt to start with a full specification of requirements. Instead, development begins by specifying and implementing just part of the software, which is then reviewed to identify further requirements. This process is then repeated, producing a new version of the software at the end of each iteration of the model.

Iterative Model - Design
Iterative process starts with a simple implementation of a subset of the software requirements and iteratively enhances the evolving versions until the full system is implemented. At each iteration, design modifications are made and new functional capabilities are added. The basic idea behind this method is to develop a system through repeated cycles (iterative) and in smaller portions at a time (incremental).

The following illustration is a representation of the Iterative and Incremental model −

SDLC Iterative Model

Iterative and Incremental development is a combination of both iterative design or iterative method and incremental build model for development. "During software development, more than one iteration of the software development cycle may be in progress at the same time." This process may be described as an "evolutionary acquisition" or "incremental build" approach."

In this incremental model, the whole requirement is divided into various builds. During each iteration, the development module goes through the requirements, design, implementation and testing phases. Each subsequent release of the module adds function to the previous release. The process continues till the complete system is ready as per the requirement.

The key to a successful use of an iterative software development lifecycle is rigorous validation of requirements, and verification & testing of each version of the software against those requirements within each cycle of the model. As the software evolves through successive cycles, tests must be repeated and extended to verify each version of the software.

### Iterative Model - Application
Like other SDLC models, Iterative and incremental development has some specific applications in the software industry. This model is most often used in the following scenarios −

Requirements of the complete system are clearly defined and understood.

Major requirements must be defined; however, some functionalities or requested enhancements may evolve with time.

There is a time to the market constraint.

A new technology is being used and is being learnt by the development team while working on the project.

Resources with needed skill sets are not available and are planned to be used on contract basis for specific iterations.

There are some high-risk features and goals which may change in the future.

#### Iterative Model - Pros and Cons
The advantage of this model is that there is a working model of the system at a very early stage of development, which makes it easier to find functional or design flaws. Finding issues at an early stage of development enables to take corrective measures in a limited budget.

The disadvantage with this SDLC model is that it is applicable only to large and bulky software development projects. This is because it is hard to break a small software system into further small serviceable increments/modules.

The advantages of the Iterative and Incremental SDLC Model are as follows −

Some working functionality can be developed quickly and early in the life cycle.

Results are obtained early and periodically.

Parallel development can be planned.

Progress can be measured.

Less costly to change the scope/requirements.

Testing and debugging during smaller iteration is easy.

Risks are identified and resolved during iteration; and each iteration is an easily managed milestone.

Easier to manage risk - High risk part is done first.

With every increment, operational product is delivered.

Issues, challenges and risks identified from each increment can be utilized/applied to the next increment.

Risk analysis is better.

It supports changing requirements.

Initial Operating time is less.

Better suited for large and mission-critical projects.

During the life cycle, software is produced early which facilitates customer evaluation and feedback.

The disadvantages of the Iterative and Incremental SDLC Model are as follows −

More resources may be required.

Although cost of change is lesser, but it is not very suitable for changing requirements.

More management attention is required.

System architecture or design issues may arise because not all requirements are gathered in the beginning of the entire life cycle.

Defining increments may require definition of the complete system.

Not suitable for smaller projects.

Management complexity is more.

End of project may not be known which is a risk.

Highly skilled resources are required for risk analysis.

Projects progress is highly dependent upon the risk analysis phase.

### SDLC - Spiral Model
The spiral model combines the idea of iterative development with the systematic, controlled aspects of the waterfall model. This Spiral model is a combination of iterative development process model and sequential linear development model i.e. the waterfall model with a very high emphasis on risk analysis. It allows incremental releases of the product or incremental refinement through each iteration around the spiral.

Spiral Model - Design
The spiral model has four phases. A software project repeatedly passes through these phases in iterations called Spirals.

#### Identification
This phase starts with gathering the business requirements in the baseline spiral. In the subsequent spirals as the product matures, identification of system requirements, subsystem requirements and unit requirements are all done in this phase.

This phase also includes understanding the system requirements by continuous communication between the customer and the system analyst. At the end of the spiral, the product is deployed in the identified market.

Design
The Design phase starts with the conceptual design in the baseline spiral and involves architectural design, logical design of modules, physical product design and the final design in the subsequent spirals.

Construct or Build
The Construct phase refers to production of the actual software product at every spiral. In the baseline spiral, when the product is just thought of and the design is being developed a POC (Proof of Concept) is developed in this phase to get customer feedback.

Then in the subsequent spirals with higher clarity on requirements and design details a working model of the software called build is produced with a version number. These builds are sent to the customer for feedback.

Evaluation and Risk Analysis
Risk Analysis includes identifying, estimating and monitoring the technical feasibility and management risks, such as schedule slippage and cost overrun. After testing the build, at the end of first iteration, the customer evaluates the software and provides feedback.

The following illustration is a representation of the Spiral Model, listing the activities in each phase.

### SDLC Spiral Model

Based on the customer evaluation, the software development process enters the next iteration and subsequently follows the linear approach to implement the feedback suggested by the customer. The process of iterations along the spiral continues throughout the life of the software.

Spiral Model Application
The Spiral Model is widely used in the software industry as it is in sync with the natural development process of any product, i.e. learning with maturity which involves minimum risk for the customer as well as the development firms.

The following pointers explain the typical uses of a Spiral Model −

When there is a budget constraint and risk evaluation is important.

For medium to high-risk projects.

Long-term project commitment because of potential changes to economic priorities as the requirements change with time.

Customer is not sure of their requirements which is usually the case.

Requirements are complex and need evaluation to get clarity.

New product line which should be released in phases to get enough customer feedback.

Significant changes are expected in the product during the development cycle.

### Spiral Model - Pros and Cons
The advantage of spiral lifecycle model is that it allows elements of the product to be added in, when they become available or known. This assures that there is no conflict with previous requirements and design.

This method is consistent with approaches that have multiple software builds and releases which allows making an orderly transition to a maintenance activity. Another positive aspect of this method is that the spiral model forces an early user involvement in the system development effort.

On the other side, it takes a very strict management to complete such products and there is a risk of running the spiral in an indefinite loop. So, the discipline of change and the extent of taking change requests is very important to develop and deploy the product successfully.

#### The advantages of the Spiral SDLC Model are as follows −

Changing requirements can be accommodated.

Allows extensive use of prototypes.

Requirements can be captured more accurately.

Users see the system early.

Development can be divided into smaller parts and the risky parts can be developed earlier which helps in better risk management.

##### The disadvantages of the Spiral SDLC Model are as follows −

Management is more complex.

End of the project may not be known early.

Not suitable for small or low risk projects and could be expensive for small projects.

Process is complex

Spiral may go on indefinitely.

Large number of intermediate stages requires excessive documentation.


## SDLC - V-Model
The V-model is an SDLC model where execution of processes happens in a sequential manner in a V-shape. It is also known as Verification and Validation model.

The V-Model is an extension of the waterfall model and is based on the association of a testing phase for each corresponding development stage. This means that for every single phase in the development cycle, there is a directly associated testing phase. This is a highly-disciplined model and the next phase starts only after completion of the previous phase.

### V-Model - Design
Under the V-Model, the corresponding testing phase of the development phase is planned in parallel. So, there are Verification phases on one side of the ‘V’ and Validation phases on the other side. The Coding Phase joins the two sides of the V-Model.

The following illustration depicts the different phases in a V-Model of the SDLC.

SDLC V-Model

V-Model - Verification Phases
There are several Verification phases in the V-Model, each of these are explained in detail below.

###### Business Requirement Analysis
This is the first phase in the development cycle where the product requirements are understood from the customer’s perspective. This phase involves detailed communication with the customer to understand his expectations and exact requirement. This is a very important activity and needs to be managed well, as most of the customers are not sure about what exactly they need. The acceptance test design planning is done at this stage as business requirements can be used as an input for acceptance testing.

#### System Design
Once you have the clear and detailed product requirements, it is time to design the complete system. The system design will have the understanding and detailing the complete hardware and communication setup for the product under development. The system test plan is developed based on the system design. Doing this at an earlier stage leaves more time for the actual test execution later.

#### Architectural Design
Architectural specifications are understood and designed in this phase. Usually more than one technical approach is proposed and based on the technical and financial feasibility the final decision is taken. The system design is broken down further into modules taking up different functionality. This is also referred to as High Level Design (HLD).

The data transfer and communication between the internal modules and with the outside world (other systems) is clearly understood and defined in this stage. With this information, integration tests can be designed and documented during this stage.

##### Module Design
In this phase, the detailed internal design for all the system modules is specified, referred to as Low Level Design (LLD). It is important that the design is compatible with the other modules in the system architecture and the other external systems. The unit tests are an essential part of any development process and helps eliminate the maximum faults and errors at a very early stage. These unit tests can be designed at this stage based on the internal module designs.

#### Coding Phase
The actual coding of the system modules designed in the design phase is taken up in the Coding phase. The best suitable programming language is decided based on the system and architectural requirements.

The coding is performed based on the coding guidelines and standards. The code goes through numerous code reviews and is optimized for best performance before the final build is checked into the repository.

#### Validation Phases
The different Validation Phases in a V-Model are explained in detail below.

#### bUnit Testing
Unit tests designed in the module design phase are executed on the code during this validation phase. Unit testing is the testing at code level and helps eliminate bugs at an early stage, though all defects cannot be uncovered by unit testing.

##### Integration Testing
Integration testing is associated with the architectural design phase. Integration tests are performed to test the coexistence and communication of the internal modules within the system.

#### System Testing
System testing is directly associated with the system design phase. System tests check the entire system functionality and the communication of the system under development with external systems. Most of the software and hardware compatibility issues can be uncovered during this system test execution.

##### Acceptance Testing
Acceptance testing is associated with the business requirement analysis phase and involves testing the product in user environment. Acceptance tests uncover the compatibility issues with the other systems available in the user environment. It also discovers the non-functional issues such as load and performance defects in the actual user environment.

#### V- Model ─ Application
V- Model application is almost the same as the waterfall model, as both the models are of sequential type. Requirements have to be very clear before the project starts, because it is usually expensive to go back and make changes. This model is used in the medical development field, as it is strictly a disciplined domain.

### The following pointers are some of the most suitable scenarios to use the V-Model application.

Requirements are well defined, clearly documented and fixed.

Product definition is stable.

Technology is not dynamic and is well understood by the project team.

There are no ambiguous or undefined requirements.

The project is short.

#### V-Model - Pros and Cons
The advantage of the V-Model method is that it is very easy to understand and apply. The simplicity of this model also makes it easier to manage. The disadvantage is that the model is not flexible to changes and just in case there is a requirement change, which is very common in today’s dynamic world, it becomes very expensive to make the change.

### The advantages of the V-Model method are as follows −

This is a highly-disciplined model and Phases are completed one at a time.

Works well for smaller projects where requirements are very well understood.

Simple and easy to understand and use.

Easy to manage due to the rigidity of the model. Each phase has specific deliverables and a review process.

### The disadvantages of the V-Model method are as follows −

High risk and uncertainty.

Not a good model for complex and object-oriented projects.

Poor model for long and ongoing projects.

Not suitable for the projects where requirements are at a moderate to high risk of changing.

Once an application is in the testing stage, it is difficult to go back and change a functionality.

No working software is produced until late during the life cycle.

## SDLC - Big Bang Model
The Big Bang model is an SDLC model where we do not follow any specific process. The development just starts with the required money and efforts as the input, and the output is the software developed which may or may not be as per customer requirement. This Big Bang Model does not follow a and there is very little planning required. Even the customer is not sure about what exactly he wants and the requirements are implemented on the fly without much analysis.

Usually this model is followed for small projects where the development teams are very small.

Big Bang Model ─ Design and Application
The Big Bang Model comprises of focusing all the possible resources in the software development and coding, with very little or no planning. The requirements are understood and implemented as they come. Any changes required may or may not need to revamp the complete software.

This model is ideal for small projects with one or two developers working together and is also useful for academic or practice projects. It is an ideal model for the product where requirements are not well understood and the final release date is not given.

#### Big Bang Model - Pros and Cons
The advantage of this Big Bang Model is that it is very simple and requires very little or no planning. Easy to manage and no formal procedure are required.

However, the Big Bang Model is a very high risk model and changes in the requirements or misunderstood requirements may even lead to complete reversal or scraping of the project. It is ideal for repetitive or small projects with minimum risks.

### The advantages of the Big Bang Model are as follows −

This is a very simple model

Little or no planning required

Easy to manage

Very few resources required

Gives flexibility to developers

It is a good learning aid for new comers or students.

#### The disadvantages of the Big Bang Model are as follows −

Very High risk and uncertainty.

Not a good model for complex and object-oriented projects.

Poor model for long and ongoing projects.

Can turn out to be very expensive if requirements are misunderstood.

### SDLC - Agile Model
Agile SDLC model is a combination of iterative and incremental process models with focus on process adaptability and customer satisfaction by rapid delivery of working software product. Agile Methods break the product into small incremental builds. These builds are provided in iterations. Each iteration typically lasts from about one to three weeks. Every iteration involves cross functional teams working simultaneously on various areas like −

Planning
Requirements Analysis
Design
Coding
Unit Testing and
Acceptance Testing.
At the end of the iteration, a working product is displayed to the customer and important stakeholders.

## What is Agile?
Agile model believes that every project needs to be handled differently and the existing methods need to be tailored to best suit the project requirements. In Agile, the tasks are divided to time boxes (small time frames) to deliver specific features for a release.

Iterative approach is taken and working software build is delivered after each iteration. Each build is incremental in terms of features; the final build holds all the features required by the customer.

Here is a graphical illustration of the Agile Model −

SDLC Agile Model

The Agile thought process had started early in the software development and started becoming popular with time due to its flexibility and adaptability.

The most popular Agile methods include Rational Unified Process (1994), Scrum (1995), Crystal Clear, Extreme Programming (1996), Adaptive Software Development, Feature Driven Development, and Dynamic Systems Development Method (DSDM) (1995). These are now collectively referred to as Agile Methodologies, after the Agile Manifesto was published in 2001.

Following are the Agile Manifesto principles −

Individuals and interactions − In Agile development, self-organization and motivation are important, as are interactions like co-location and pair programming.

Working software − Demo working software is considered the best means of communication with the customers to understand their requirements, instead of just depending on documentation.

Customer collaboration − As the requirements cannot be gathered completely in the beginning of the project due to various factors, continuous customer interaction is very important to get proper product requirements.

Responding to change − Agile Development is focused on quick responses to change and continuous development.

Agile Vs Traditional SDLC Models
Agile is based on the adaptive software development methods, whereas the traditional SDLC models like the waterfall model is based on a predictive approach. Predictive teams in the traditional SDLC models usually work with detailed planning and have a complete forecast of the exact tasks and features to be delivered in the next few months or during the product life cycle.

Predictive methods entirely depend on the requirement analysis and planning done in the beginning of cycle. Any changes to be incorporated go through a strict change control management and prioritization.

Agile uses an adaptive approach where there is no detailed planning and there is clarity on future tasks only in respect of what features need to be developed. There is feature driven development and the team adapts to the changing product requirements dynamically. The product is tested very frequently, through the release iterations, minimizing the risk of any major failures in future.

Customer Interaction is the backbone of this Agile methodology, and open communication with minimum documentation are the typical features of Agile development environment. The agile teams work in close collaboration with each other and are most often located in the same geographical location.

Agile Model - Pros and Cons
Agile methods are being widely accepted in the software world recently. However, this method may not always be suitable for all products. Here are some pros and cons of the Agile model.

#### The advantages of the Agile Model are as follows −

Is a very realistic approach to software development.

Promotes teamwork and cross training.

Functionality can be developed rapidly and demonstrated.

Resource requirements are minimum.

Suitable for fixed or changing requirements

Delivers early partial working solutions.

Good model for environments that change steadily.

Minimal rules, documentation easily employed.

Enables concurrent development and delivery within an overall planned context.

Little or no planning required.

Easy to manage.

Gives flexibility to developers.

### The disadvantages of the Agile Model are as follows −

Not suitable for handling complex dependencies.

More risk of sustainability, maintainability and extensibility.

An overall plan, an agile leader and agile PM practice is a must without which it will not work.

Strict delivery management dictates the scope, functionality to be delivered, and adjustments to meet the deadlines.

Depends heavily on customer interaction, so if customer is not clear, team can be driven in the wrong direction.

There is a very high individual dependency, since there is minimum documentation generated.

Transfer of technology to new team members may be quite challenging due to lack of documentation.

## SDLC - RAD Model
The RAD (Rapid Application Development) model is based on prototyping and iterative development with no specific planning involved. The process of writing the software itself involves the planning required for developing the product.

Rapid Application Development focuses on gathering customer requirements through workshops or focus groups, early testing of the prototypes by the customer using iterative concept, reuse of the existing prototypes (components), continuous integration and rapid delivery.

### What is RAD?
Rapid application development is a software development methodology that uses minimal planning in favor of rapid prototyping. A prototype is a working model that is functionally equivalent to a component of the product.

In the RAD model, the functional modules are developed in parallel as prototypes and are integrated to make the complete product for faster product delivery. Since there is no detailed preplanning, it makes it easier to incorporate the changes within the development process.

RAD projects follow iterative and incremental model and have small teams comprising of developers, domain experts, customer representatives and other IT resources working progressively on their component or prototype.

The most important aspect for this model to be successful is to make sure that the prototypes developed are reusable.

RAD Model Design
RAD model distributes the analysis, design, build and test phases into a series of short, iterative development cycles.

Following are the various phases of the RAD Model −

Business Modeling
The business model for the product under development is designed in terms of flow of information and the distribution of information between various business channels. A complete business analysis is performed to find the vital information for business, how it can be obtained, how and when is the information processed and what are the factors driving successful flow of information.

Data Modeling
The information gathered in the Business Modeling phase is reviewed and analyzed to form sets of data objects vital for the business. The attributes of all data sets is identified and defined. The relation between these data objects are established and defined in detail in relevance to the business model.

Process Modeling
The data object sets defined in the Data Modeling phase are converted to establish the business information flow needed to achieve specific business objectives as per the business model. The process model for any changes or enhancements to the data object sets is defined in this phase. Process descriptions for adding, deleting, retrieving or modifying a data object are given.

Application Generation
The actual system is built and coding is done by using automation tools to convert process and data models into actual prototypes.

Testing and Turnover
The overall testing time is reduced in the RAD model as the prototypes are independently tested during every iteration. However, the data flow and the interfaces between all the components need to be thoroughly tested with complete test coverage. Since most of the programming components have already been tested, it reduces the risk of any major issues.

The following illustration describes the RAD Model in detail.

SDLC RAD Model

RAD Model Vs Traditional SDLC
The traditional SDLC follows a rigid process models with high emphasis on requirement analysis and gathering before the coding starts. It puts pressure on the customer to sign off the requirements before the project starts and the customer doesn’t get the feel of the product as there is no working build available for a long time.

The customer may need some changes after he gets to see the software. However, the change process is quite rigid and it may not be feasible to incorporate major changes in the product in the traditional SDLC.

The RAD model focuses on iterative and incremental delivery of working models to the customer. This results in rapid delivery to the customer and customer involvement during the complete development cycle of product reducing the risk of non-conformance with the actual user requirements.

RAD Model - Application
RAD model can be applied successfully to the projects in which clear modularization is possible. If the project cannot be broken into modules, RAD may fail.

The following pointers describe the typical scenarios where RAD can be used −

RAD should be used only when a system can be modularized to be delivered in an incremental manner.

It should be used if there is a high availability of designers for modeling.

It should be used only if the budget permits use of automated code generating tools.

RAD SDLC model should be chosen only if domain experts are available with relevant business knowledge.

Should be used where the requirements change during the project and working prototypes are to be presented to customer in small iterations of 2-3 months.

RAD Model - Pros and Cons
RAD model enables rapid delivery as it reduces the overall development time due to the reusability of the components and parallel development. RAD works well only if high skilled engineers are available and the customer is also committed to achieve the targeted prototype in the given time frame. If there is commitment lacking on either side the model may fail.

### The advantages of the RAD Model are as follows −

Changing requirements can be accommodated.

Progress can be measured.

Iteration time can be short with use of powerful RAD tools.

Productivity with fewer people in a short time.

Reduced development time.

Increases reusability of components.

Quick initial reviews occur.

Encourages customer feedback.

Integration from very beginning solves a lot of integration issues.

### The disadvantages of the RAD Model are as follows −

Dependency on technically strong team members for identifying business requirements.

Only system that can be modularized can be built using RAD.

Requires highly skilled developers/designers.

High dependency on modeling skills.

Inapplicable to cheaper projects as cost of modeling and automated code generation is very high.

Management complexity is more.

Suitable for systems that are component based and scalable.

Requires user involvement throughout the life cycle.

Suitable for project requiring shorter development times.


## SDLC - Software Prototype Model
The Software Prototyping refers to building software application prototypes which displays the functionality of the product under development, but may not actually hold the exact logic of the original software.

Software prototyping is becoming very popular as a software development model, as it enables to understand customer requirements at an early stage of development. It helps get valuable feedback from the customer and helps software designers and developers understand about what exactly is expected from the product under development.

What is Software Prototyping?
Prototype is a working model of software with some limited functionality. The prototype does not always hold the exact logic used in the actual software application and is an extra effort to be considered under effort estimation.

Prototyping is used to allow the users evaluate developer proposals and try them out before implementation. It also helps understand the requirements which are user specific and may not have been considered by the developer during product design.

Following is a stepwise approach explained to design a software prototype.

Basic Requirement Identification
This step involves understanding the very basics product requirements especially in terms of user interface. The more intricate details of the internal design and external aspects like performance and security can be ignored at this stage.

Developing the initial Prototype
The initial Prototype is developed in this stage, where the very basic requirements are showcased and user interfaces are provided. These features may not exactly work in the same manner internally in the actual software developed. While, the workarounds are used to give the same look and feel to the customer in the prototype developed.

Review of the Prototype
The prototype developed is then presented to the customer and the other important stakeholders in the project. The feedback is collected in an organized manner and used for further enhancements in the product under development.

Revise and Enhance the Prototype
The feedback and the review comments are discussed during this stage and some negotiations happen with the customer based on factors like – time and budget constraints and technical feasibility of the actual implementation. The changes accepted are again incorporated in the new Prototype developed and the cycle repeats until the customer expectations are met.

Prototypes can have horizontal or vertical dimensions. A Horizontal prototype displays the user interface for the product and gives a broader view of the entire system, without concentrating on internal functions. A Vertical prototype on the other side is a detailed elaboration of a specific function or a sub system in the product.

The purpose of both horizontal and vertical prototype is different. Horizontal prototypes are used to get more information on the user interface level and the business requirements. It can even be presented in the sales demos to get business in the market. Vertical prototypes are technical in nature and are used to get details of the exact functioning of the sub systems. For example, database requirements, interaction and data processing loads in a given sub system.

Software Prototyping - Types
There are different types of software prototypes used in the industry. Following are the major software prototyping types used widely −

Throwaway/Rapid Prototyping
Throwaway prototyping is also called as rapid or close ended prototyping. This type of prototyping uses very little efforts with minimum requirement analysis to build a prototype. Once the actual requirements are understood, the prototype is discarded and the actual system is developed with a much clear understanding of user requirements.

Evolutionary Prototyping
Evolutionary prototyping also called as breadboard prototyping is based on building actual functional prototypes with minimal functionality in the beginning. The prototype developed forms the heart of the future prototypes on top of which the entire system is built. By using evolutionary prototyping, the well-understood requirements are included in the prototype and the requirements are added as and when they are understood.

Incremental Prototyping
Incremental prototyping refers to building multiple functional prototypes of the various sub-systems and then integrating all the available prototypes to form a complete system.

Extreme Prototyping
Extreme prototyping is used in the web development domain. It consists of three sequential phases. First, a basic prototype with all the existing pages is presented in the HTML format. Then the data processing is simulated using a prototype services layer. Finally, the services are implemented and integrated to the final prototype. This process is called Extreme Prototyping used to draw attention to the second phase of the process, where a fully functional UI is developed with very little regard to the actual services.

Software Prototyping - Application
Software Prototyping is most useful in development of systems having high level of user interactions such as online systems. Systems which need users to fill out forms or go through various screens before data is processed can use prototyping very effectively to give the exact look and feel even before the actual software is developed.

Software that involves too much of data processing and most of the functionality is internal with very little user interface does not usually benefit from prototyping. Prototype development could be an extra overhead in such projects and may need lot of extra efforts.

Software Prototyping - Pros and Cons
Software prototyping is used in typical cases and the decision should be taken very carefully so that the efforts spent in building the prototype add considerable value to the final software developed. The model has its own pros and cons discussed as follows.

### The advantages of the Prototyping Model are as follows −

Increased user involvement in the product even before its implementation.

Since a working model of the system is displayed, the users get a better understanding of the system being developed.

Reduces time and cost as the defects can be detected much earlier.

Quicker user feedback is available leading to better solutions.

Missing functionality can be identified easily.

Confusing or difficult functions can be identified.

### The Disadvantages of the Prototyping Model are as follows −

Risk of insufficient requirement analysis owing to too much dependency on the prototype.

Users may get confused in the prototypes and actual systems.

Practically, this methodology may increase the complexity of the system as scope of the system may expand beyond original plans.

Developers may try to reuse the existing prototypes to build the actual system, even when it is not technically feasible.

The effort invested in building prototypes may be too much if it is not monitored properly.
